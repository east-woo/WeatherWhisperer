{"ast":null,"code":"/**\n * @module ol/source/Raster\n */\nimport Disposable from '../Disposable.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ImageCanvas from '../ImageCanvas.js';\nimport ImageLayer from '../layer/Image.js';\nimport ImageSource from './Image.js';\nimport Source from './Source.js';\nimport TileLayer from '../layer/Tile.js';\nimport TileQueue from '../TileQueue.js';\nimport TileSource from './Tile.js';\nimport { createCanvasContext2D } from '../dom.js';\nimport { create as createTransform } from '../transform.js';\nimport { equals, getCenter, getHeight, getWidth } from '../extent.js';\nimport { getUid } from '../util.js';\nlet hasImageData = true;\ntry {\n  new ImageData(10, 10);\n} catch (_) {\n  hasImageData = false;\n}\n\n/** @type {CanvasRenderingContext2D} */\nlet context;\n\n/**\n * @param {Uint8ClampedArray} data Image data.\n * @param {number} width Number of columns.\n * @param {number} height Number of rows.\n * @return {ImageData} Image data.\n */\nexport function newImageData(data, width, height) {\n  if (hasImageData) {\n    return new ImageData(data, width, height);\n  }\n  if (!context) {\n    context = document.createElement('canvas').getContext('2d');\n  }\n  const imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  return imageData;\n}\n\n/**\n * @typedef {Object} MinionData\n * @property {Array<ArrayBuffer>} buffers Array of buffers.\n * @property {Object} meta Operation metadata.\n * @property {boolean} imageOps The operation is an image operation.\n * @property {number} width The width of the image.\n * @property {number} height The height of the image.\n */\n\n/* istanbul ignore next */\n/**\n * Create a function for running operations.  This function is serialized for\n * use in a worker.\n * @param {function(Array, Object):*} operation The operation.\n * @return {function(MinionData):ArrayBuffer} A function that takes an object with\n * buffers, meta, imageOps, width, and height properties and returns an array\n * buffer.\n */\nfunction createMinion(operation) {\n  let workerHasImageData = true;\n  try {\n    new ImageData(10, 10);\n  } catch (_) {\n    workerHasImageData = false;\n  }\n  function newWorkerImageData(data, width, height) {\n    if (workerHasImageData) {\n      return new ImageData(data, width, height);\n    }\n    return {\n      data: data,\n      width: width,\n      height: height\n    };\n  }\n  return function (data) {\n    // bracket notation for minification support\n    const buffers = data['buffers'];\n    const meta = data['meta'];\n    const imageOps = data['imageOps'];\n    const width = data['width'];\n    const height = data['height'];\n    const numBuffers = buffers.length;\n    const numBytes = buffers[0].byteLength;\n    if (imageOps) {\n      const images = new Array(numBuffers);\n      for (let b = 0; b < numBuffers; ++b) {\n        images[b] = newWorkerImageData(new Uint8ClampedArray(buffers[b]), width, height);\n      }\n      const output = operation(images, meta).data;\n      return output.buffer;\n    }\n    const output = new Uint8ClampedArray(numBytes);\n    const arrays = new Array(numBuffers);\n    const pixels = new Array(numBuffers);\n    for (let b = 0; b < numBuffers; ++b) {\n      arrays[b] = new Uint8ClampedArray(buffers[b]);\n      pixels[b] = [0, 0, 0, 0];\n    }\n    for (let i = 0; i < numBytes; i += 4) {\n      for (let j = 0; j < numBuffers; ++j) {\n        const array = arrays[j];\n        pixels[j][0] = array[i];\n        pixels[j][1] = array[i + 1];\n        pixels[j][2] = array[i + 2];\n        pixels[j][3] = array[i + 3];\n      }\n      const pixel = operation(pixels, meta);\n      output[i] = pixel[0];\n      output[i + 1] = pixel[1];\n      output[i + 2] = pixel[2];\n      output[i + 3] = pixel[3];\n    }\n    return output.buffer;\n  };\n}\n\n/**\n * Create a worker for running operations.\n * @param {ProcessorOptions} config Processor options.\n * @param {function(MessageEvent): void} onMessage Called with a message event.\n * @return {Worker} The worker.\n */\nfunction createWorker(config, onMessage) {\n  const lib = Object.keys(config.lib || {}).map(function (name) {\n    return 'const ' + name + ' = ' + config.lib[name].toString() + ';';\n  });\n  const lines = lib.concat(['const __minion__ = (' + createMinion.toString() + ')(', config.operation.toString(), ');', 'self.addEventListener(\"message\", function(event) {', '  const buffer = __minion__(event.data);', '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);', '});']);\n  const worker = new Worker(typeof Blob === 'undefined' ? 'data:text/javascript;base64,' + Buffer.from(lines.join('\\n'), 'binary').toString('base64') : URL.createObjectURL(new Blob(lines, {\n    type: 'text/javascript'\n  })));\n  worker.addEventListener('message', onMessage);\n  return worker;\n}\n\n/**\n * @typedef {Object} FauxMessageEvent\n * @property {Object} data Message data.\n */\n\n/**\n * Create a faux worker for running operations.\n * @param {ProcessorOptions} config Configuration.\n * @param {function(FauxMessageEvent): void} onMessage Called with a message event.\n * @return {Object} The faux worker.\n */\nfunction createFauxWorker(config, onMessage) {\n  const minion = createMinion(config.operation);\n  let terminated = false;\n  return {\n    postMessage: function (data) {\n      setTimeout(function () {\n        if (terminated) {\n          return;\n        }\n        onMessage({\n          data: {\n            buffer: minion(data),\n            meta: data['meta']\n          }\n        });\n      }, 0);\n    },\n    terminate: function () {\n      terminated = true;\n    }\n  };\n}\n\n/**\n * @typedef {function(Error, ImageData, (Object|Array<Object>)): void} JobCallback\n */\n\n/**\n * @typedef {Object} Job\n * @property {Object} meta Job metadata.\n * @property {Array<ImageData>} inputs Array of input data.\n * @property {JobCallback} callback Called when the job is complete.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {number} threads Number of workers to spawn.\n * @property {Operation} operation The operation.\n * @property {Object<string, Function>} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} queue The number of queued jobs to allow.\n * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.\n */\n\n/**\n * @classdesc\n * A processor runs pixel or image operations in workers.\n */\nexport class Processor extends Disposable {\n  /**\n   * @param {ProcessorOptions} config Configuration.\n   */\n  constructor(config) {\n    super();\n    this._imageOps = !!config.imageOps;\n    let threads;\n    if (config.threads === 0) {\n      threads = 0;\n    } else if (this._imageOps) {\n      threads = 1;\n    } else {\n      threads = config.threads || 1;\n    }\n\n    /**\n     * @type {Array<Worker>}\n     */\n    const workers = new Array(threads);\n    if (threads) {\n      for (let i = 0; i < threads; ++i) {\n        workers[i] = createWorker(config, this._onWorkerMessage.bind(this, i));\n      }\n    } else {\n      workers[0] = createFauxWorker(config, this._onWorkerMessage.bind(this, 0));\n    }\n    this._workers = workers;\n\n    /**\n     * @type {Array<Job>}\n     * @private\n     */\n    this._queue = [];\n    this._maxQueueLength = config.queue || Infinity;\n    this._running = 0;\n\n    /**\n     * @type {Object<number, any>}\n     * @private\n     */\n    this._dataLookup = {};\n\n    /**\n     * @type {Job}\n     * @private\n     */\n    this._job = null;\n  }\n\n  /**\n   * Run operation on input data.\n   * @param {Array<ImageData>} inputs Array of image data.\n   * @param {Object} meta A user data object.  This is passed to all operations\n   *     and must be serializable.\n   * @param {function(Error, ImageData, Object): void} callback Called when work\n   *     completes.  The first argument is any error.  The second is the ImageData\n   *     generated by operations.  The third is the user data object.\n   */\n  process(inputs, meta, callback) {\n    this._enqueue({\n      inputs: inputs,\n      meta: meta,\n      callback: callback\n    });\n    this._dispatch();\n  }\n\n  /**\n   * Add a job to the queue.\n   * @param {Job} job The job.\n   */\n  _enqueue(job) {\n    this._queue.push(job);\n    while (this._queue.length > this._maxQueueLength) {\n      this._queue.shift().callback(null, null);\n    }\n  }\n\n  /**\n   * Dispatch a job.\n   */\n  _dispatch() {\n    if (this._running || this._queue.length === 0) {\n      return;\n    }\n    const job = this._queue.shift();\n    this._job = job;\n    const width = job.inputs[0].width;\n    const height = job.inputs[0].height;\n    const buffers = job.inputs.map(function (input) {\n      return input.data.buffer;\n    });\n    const threads = this._workers.length;\n    this._running = threads;\n    if (threads === 1) {\n      this._workers[0].postMessage({\n        buffers: buffers,\n        meta: job.meta,\n        imageOps: this._imageOps,\n        width: width,\n        height: height\n      }, buffers);\n      return;\n    }\n    const length = job.inputs[0].data.length;\n    const segmentLength = 4 * Math.ceil(length / 4 / threads);\n    for (let i = 0; i < threads; ++i) {\n      const offset = i * segmentLength;\n      const slices = [];\n      for (let j = 0, jj = buffers.length; j < jj; ++j) {\n        slices.push(buffers[j].slice(offset, offset + segmentLength));\n      }\n      this._workers[i].postMessage({\n        buffers: slices,\n        meta: job.meta,\n        imageOps: this._imageOps,\n        width: width,\n        height: height\n      }, slices);\n    }\n  }\n\n  /**\n   * Handle messages from the worker.\n   * @param {number} index The worker index.\n   * @param {MessageEvent} event The message event.\n   */\n  _onWorkerMessage(index, event) {\n    if (this.disposed) {\n      return;\n    }\n    this._dataLookup[index] = event.data;\n    --this._running;\n    if (this._running === 0) {\n      this._resolveJob();\n    }\n  }\n\n  /**\n   * Resolve a job.  If there are no more worker threads, the processor callback\n   * will be called.\n   */\n  _resolveJob() {\n    const job = this._job;\n    const threads = this._workers.length;\n    let data, meta;\n    if (threads === 1) {\n      data = new Uint8ClampedArray(this._dataLookup[0]['buffer']);\n      meta = this._dataLookup[0]['meta'];\n    } else {\n      const length = job.inputs[0].data.length;\n      data = new Uint8ClampedArray(length);\n      meta = new Array(threads);\n      const segmentLength = 4 * Math.ceil(length / 4 / threads);\n      for (let i = 0; i < threads; ++i) {\n        const buffer = this._dataLookup[i]['buffer'];\n        const offset = i * segmentLength;\n        data.set(new Uint8ClampedArray(buffer), offset);\n        meta[i] = this._dataLookup[i]['meta'];\n      }\n    }\n    this._job = null;\n    this._dataLookup = {};\n    job.callback(null, newImageData(data, job.inputs[0].width, job.inputs[0].height), meta);\n    this._dispatch();\n  }\n\n  /**\n   * Terminate all workers associated with the processor.\n   */\n  disposeInternal() {\n    for (let i = 0; i < this._workers.length; ++i) {\n      this._workers[i].terminate();\n    }\n    this._workers.length = 0;\n  }\n}\n\n/**\n * A function that takes an array of input data, performs some operation, and\n * returns an array of output data.\n * For `pixel` type operations, the function will be called with an array of\n * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the\n * range of 0 - 255. It should return a single pixel array.\n * For `'image'` type operations, functions will be called with an array of\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)\n * and should return a single\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n * The operations\n * are called with a second \"data\" argument, which can be used for storage.  The\n * data object is accessible from raster events, where it can be initialized in\n * \"beforeoperations\" and accessed again in \"afteroperations\".\n *\n * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):\n *     (Array<number>|ImageData)} Operation\n */\n\n/**\n * @enum {string}\n */\nconst RasterEventType = {\n  /**\n   * Triggered before operations are run.  Listeners will receive an event object with\n   * a `data` property that can be used to make data available to operations.\n   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations\n   * @api\n   */\n  BEFOREOPERATIONS: 'beforeoperations',\n  /**\n   * Triggered after operations are run.  Listeners will receive an event object with\n   * a `data` property.  If more than one thread is used, `data` will be an array of\n   * objects.  If a single thread is used, `data` will be a single object.\n   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations\n   * @api\n   */\n  AFTEROPERATIONS: 'afteroperations'\n};\n\n/**\n * @typedef {'pixel' | 'image'} RasterOperationType\n * Raster operation type. Supported values are `'pixel'` and `'image'`.\n */\n\n/**\n * @typedef {import(\"./Image.js\").ImageSourceEventTypes|'beforeoperations'|'afteroperations'} RasterSourceEventTypes\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Raster~RasterSource} instances are instances of this\n * type.\n */\nexport class RasterSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Object|Array<Object>} data An object made available to operations.  For \"afteroperations\" evenets\n   * this will be an array of objects if more than one thread is used.\n   */\n  constructor(type, frameState, data) {\n    super(type);\n\n    /**\n     * The raster extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = frameState.extent;\n\n    /**\n     * The pixel resolution (map units per pixel).\n     * @type {number}\n     * @api\n     */\n    this.resolution = frameState.viewState.resolution / frameState.pixelRatio;\n\n    /**\n     * An object made available to all operations.  This can be used by operations\n     * as a storage object (e.g. for calculating statistics).\n     * @type {Object}\n     * @api\n     */\n    this.data = data;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources Input\n * sources or layers.  For vector data, use an VectorImage layer.\n * @property {Operation} [operation] Raster operation.\n * The operation will be called with data from input sources\n * and the output will be assigned to the raster source.\n * @property {Object} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} [threads] By default, operations will be run in a single worker thread.\n * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can\n * be run in multiple worker threads.  Note that there is additional overhead in\n * transferring data to multiple workers, and that depending on the user's\n * system, it may not be possible to parallelize the work.\n * @property {RasterOperationType} [operationType='pixel'] Operation type.\n * Supported values are `'pixel'` and `'image'`.  By default,\n * `'pixel'` operations are assumed, and operations will be called with an\n * array of pixels from input sources.  If set to `'image'`, operations will\n * be called with an array of ImageData objects from input sources.\n * @property {Array<number>|null} [resolutions] Resolutions. If specified, raster operations will only\n * be run at the given resolutions.  By default, the resolutions of the first source with resolutions\n * specified will be used, if any. Set to `null` to use any view resolution instead.\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Image.js\").ImageSourceEventTypes, import(\"./Image.js\").ImageSourceEvent, Return> &\n *   import(\"../Observable\").OnSignature<RasterSourceEventTypes, RasterSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\n *     |RasterSourceEventTypes, Return>} RasterSourceOnSignature\n */\n\n/**\n * @classdesc\n * A source that transforms data from any number of input sources using an\n * {@link module:ol/source/Raster~Operation} function to transform input pixel values into\n * output pixel values.\n *\n * @fires module:ol/source/Raster.RasterSourceEvent\n * @api\n */\nclass RasterSource extends ImageSource {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super({\n      projection: null\n    });\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {RasterSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {Processor}\n     */\n    this.processor_ = null;\n\n    /**\n     * @private\n     * @type {RasterOperationType}\n     */\n    this.operationType_ = options.operationType !== undefined ? options.operationType : 'pixel';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threads_ = options.threads !== undefined ? options.threads : 1;\n\n    /**\n     * @private\n     * @type {Array<import(\"../layer/Layer.js\").default>}\n     */\n    this.layers_ = createLayers(options.sources);\n    const changed = this.changed.bind(this);\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      this.layers_[i].addEventListener(EventType.CHANGE, changed);\n    }\n\n    /** @type {boolean} */\n    this.useResolutions_ = options.resolutions !== null;\n\n    /**\n     * @private\n     * @type {import(\"../TileQueue.js\").default}\n     */\n    this.tileQueue_ = new TileQueue(function () {\n      return 1;\n    }, this.processSources_.bind(this));\n\n    /**\n     * The most recently requested frame state.\n     * @type {import(\"../Map.js\").FrameState}\n     * @private\n     */\n    this.requestedFrameState_;\n\n    /**\n     * The most recently rendered image canvas.\n     * @type {import(\"../ImageCanvas.js\").default}\n     * @private\n     */\n    this.renderedImageCanvas_ = null;\n\n    /**\n     * The most recently rendered revision.\n     * @type {number}\n     */\n    this.renderedRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").FrameState}\n     */\n    this.frameState_ = {\n      animate: false,\n      coordinateToPixelTransform: createTransform(),\n      declutterTree: null,\n      extent: null,\n      index: 0,\n      layerIndex: 0,\n      layerStatesArray: getLayerStatesArray(this.layers_),\n      pixelRatio: 1,\n      pixelToCoordinateTransform: createTransform(),\n      postRenderFunctions: [],\n      size: [0, 0],\n      tileQueue: this.tileQueue_,\n      time: Date.now(),\n      usedTiles: {},\n      viewState: ( /** @type {import(\"../View.js\").State} */{\n        rotation: 0\n      }),\n      viewHints: [],\n      wantedTiles: {},\n      mapId: getUid(this),\n      renderTargets: {}\n    };\n    this.setAttributions(function (frameState) {\n      const attributions = [];\n      for (let index = 0, iMax = options.sources.length; index < iMax; ++index) {\n        const sourceOrLayer = options.sources[index];\n        const source = sourceOrLayer instanceof Source ? sourceOrLayer : sourceOrLayer.getSource();\n        if (!source) {\n          continue;\n        }\n        const attributionGetter = source.getAttributions();\n        if (typeof attributionGetter === 'function') {\n          const sourceAttribution = attributionGetter(frameState);\n          attributions.push.apply(attributions, sourceAttribution);\n        }\n      }\n      return attributions.length !== 0 ? attributions : null;\n    });\n    if (options.operation !== undefined) {\n      this.setOperation(options.operation, options.lib);\n    }\n  }\n\n  /**\n   * Set the operation.\n   * @param {Operation} operation New operation.\n   * @param {Object} [lib] Functions that will be available to operations run\n   *     in a worker.\n   * @api\n   */\n  setOperation(operation, lib) {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n    this.processor_ = new Processor({\n      operation: operation,\n      imageOps: this.operationType_ === 'image',\n      queue: 1,\n      lib: lib,\n      threads: this.threads_\n    });\n    this.changed();\n  }\n\n  /**\n   * Update the stored frame state.\n   * @param {import(\"../extent.js\").Extent} extent The view extent (in map units).\n   * @param {number} resolution The view resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n   * @return {import(\"../Map.js\").FrameState} The updated frame state.\n   * @private\n   */\n  updateFrameState_(extent, resolution, projection) {\n    const frameState = /** @type {import(\"../Map.js\").FrameState} */\n    Object.assign({}, this.frameState_);\n    frameState.viewState = /** @type {import(\"../View.js\").State} */\n    Object.assign({}, frameState.viewState);\n    const center = getCenter(extent);\n    frameState.size[0] = Math.ceil(getWidth(extent) / resolution);\n    frameState.size[1] = Math.ceil(getHeight(extent) / resolution);\n    frameState.extent = [center[0] - frameState.size[0] * resolution / 2, center[1] - frameState.size[1] * resolution / 2, center[0] + frameState.size[0] * resolution / 2, center[1] + frameState.size[1] * resolution / 2];\n    frameState.time = Date.now();\n    const viewState = frameState.viewState;\n    viewState.center = center;\n    viewState.projection = projection;\n    viewState.resolution = resolution;\n    return frameState;\n  }\n\n  /**\n   * Determine if all sources are ready.\n   * @return {boolean} All sources are ready.\n   * @private\n   */\n  allSourcesReady_() {\n    let ready = true;\n    let source;\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      source = this.layers_[i].getSource();\n      if (!source || source.getState() !== 'ready') {\n        ready = false;\n        break;\n      }\n    }\n    return ready;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\n   */\n  getImage(extent, resolution, pixelRatio, projection) {\n    if (!this.allSourcesReady_()) {\n      return null;\n    }\n    this.tileQueue_.loadMoreTiles(16, 16);\n    resolution = this.findNearestResolution(resolution);\n    const frameState = this.updateFrameState_(extent, resolution, projection);\n    this.requestedFrameState_ = frameState;\n\n    // check if we can't reuse the existing ol/ImageCanvas\n    if (this.renderedImageCanvas_) {\n      const renderedResolution = this.renderedImageCanvas_.getResolution();\n      const renderedExtent = this.renderedImageCanvas_.getExtent();\n      if (resolution !== renderedResolution || !equals(frameState.extent, renderedExtent)) {\n        this.renderedImageCanvas_ = null;\n      }\n    }\n    if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) {\n      this.processSources_();\n    }\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    }\n    return this.renderedImageCanvas_;\n  }\n\n  /**\n   * Start processing source data.\n   * @private\n   */\n  processSources_() {\n    const frameState = this.requestedFrameState_;\n    const len = this.layers_.length;\n    const imageDatas = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      frameState.layerIndex = i;\n      frameState.renderTargets = {};\n      const imageData = getImageData(this.layers_[i], frameState);\n      if (imageData) {\n        imageDatas[i] = imageData;\n      } else {\n        return;\n      }\n    }\n    const data = {};\n    this.dispatchEvent(new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data));\n    this.processor_.process(imageDatas, data, this.onWorkerComplete_.bind(this, frameState));\n  }\n\n  /**\n   * Called when pixel processing is complete.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Error} err Any error during processing.\n   * @param {ImageData} output The output image data.\n   * @param {Object|Array<Object>} data The user data (or an array if more than one thread).\n   * @private\n   */\n  onWorkerComplete_(frameState, err, output, data) {\n    if (err || !output) {\n      return;\n    }\n\n    // do nothing if extent or resolution changed\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    if (resolution !== this.requestedFrameState_.viewState.resolution || !equals(extent, this.requestedFrameState_.extent)) {\n      return;\n    }\n    let context;\n    if (this.renderedImageCanvas_) {\n      context = this.renderedImageCanvas_.getImage().getContext('2d');\n    } else {\n      const width = Math.round(getWidth(extent) / resolution);\n      const height = Math.round(getHeight(extent) / resolution);\n      context = createCanvasContext2D(width, height);\n      this.renderedImageCanvas_ = new ImageCanvas(extent, resolution, 1, context.canvas);\n    }\n    context.putImageData(output, 0, 0);\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    } else {\n      this.changed();\n    }\n    this.renderedRevision_ = this.getRevision();\n    this.dispatchEvent(new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data));\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   */\n  getResolutions(projection) {\n    if (!this.useResolutions_) {\n      return null;\n    }\n    let resolutions = super.getResolutions();\n    if (!resolutions) {\n      for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n        const source = this.layers_[i].getSource();\n        resolutions = source.getResolutions(projection);\n        if (resolutions) {\n          break;\n        }\n      }\n    }\n    return resolutions;\n  }\n  disposeInternal() {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n    super.disposeInternal();\n  }\n}\n\n/**\n * Clean up and unregister the worker.\n * @function\n * @api\n */\nRasterSource.prototype.dispose;\n\n/**\n * A reusable canvas context.\n * @type {CanvasRenderingContext2D}\n * @private\n */\nlet sharedContext = null;\n\n/**\n * Get image data from a layer.\n * @param {import(\"../layer/Layer.js\").default} layer Layer to render.\n * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n * @return {ImageData} The image data.\n */\nfunction getImageData(layer, frameState) {\n  const renderer = layer.getRenderer();\n  if (!renderer) {\n    throw new Error('Unsupported layer type: ' + layer);\n  }\n  if (!renderer.prepareFrame(frameState)) {\n    return null;\n  }\n  const width = frameState.size[0];\n  const height = frameState.size[1];\n  if (width === 0 || height === 0) {\n    return null;\n  }\n  const container = renderer.renderFrame(frameState, null);\n  let element;\n  if (container instanceof HTMLCanvasElement) {\n    element = container;\n  } else {\n    if (container) {\n      element = container.firstElementChild;\n    }\n    if (!(element instanceof HTMLCanvasElement)) {\n      throw new Error('Unsupported rendered element: ' + element);\n    }\n    if (element.width === width && element.height === height) {\n      const context = element.getContext('2d');\n      return context.getImageData(0, 0, width, height);\n    }\n  }\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(width, height, undefined, {\n      willReadFrequently: true\n    });\n  } else {\n    const canvas = sharedContext.canvas;\n    if (canvas.width !== width || canvas.height !== height) {\n      sharedContext = createCanvasContext2D(width, height, undefined, {\n        willReadFrequently: true\n      });\n    } else {\n      sharedContext.clearRect(0, 0, width, height);\n    }\n  }\n  sharedContext.drawImage(element, 0, 0, width, height);\n  return sharedContext.getImageData(0, 0, width, height);\n}\n\n/**\n * Get a list of layer states from a list of layers.\n * @param {Array<import(\"../layer/Layer.js\").default>} layers Layers.\n * @return {Array<import(\"../layer/Layer.js\").State>} The layer states.\n */\nfunction getLayerStatesArray(layers) {\n  return layers.map(function (layer) {\n    return layer.getLayerState();\n  });\n}\n\n/**\n * Create layers for all sources.\n * @param {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources The sources.\n * @return {Array<import(\"../layer/Layer.js\").default>} Array of layers.\n */\nfunction createLayers(sources) {\n  const len = sources.length;\n  const layers = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    layers[i] = createLayer(sources[i]);\n  }\n  return layers;\n}\n\n/**\n * Create a layer for the provided source.\n * @param {import(\"./Source.js\").default|import(\"../layer/Layer.js\").default} layerOrSource The layer or source.\n * @return {import(\"../layer/Layer.js\").default} The layer.\n */\nfunction createLayer(layerOrSource) {\n  // @type {import(\"../layer/Layer.js\").default}\n  let layer;\n  if (layerOrSource instanceof Source) {\n    if (layerOrSource instanceof TileSource) {\n      layer = new TileLayer({\n        source: layerOrSource\n      });\n    } else if (layerOrSource instanceof ImageSource) {\n      layer = new ImageLayer({\n        source: layerOrSource\n      });\n    }\n  } else {\n    layer = layerOrSource;\n  }\n  return layer;\n}\nexport default RasterSource;","map":{"version":3,"names":["Disposable","Event","EventType","ImageCanvas","ImageLayer","ImageSource","Source","TileLayer","TileQueue","TileSource","createCanvasContext2D","create","createTransform","equals","getCenter","getHeight","getWidth","getUid","hasImageData","ImageData","_","context","newImageData","data","width","height","document","createElement","getContext","imageData","createImageData","set","createMinion","operation","workerHasImageData","newWorkerImageData","buffers","meta","imageOps","numBuffers","length","numBytes","byteLength","images","Array","b","Uint8ClampedArray","output","buffer","arrays","pixels","i","j","array","pixel","createWorker","config","onMessage","lib","Object","keys","map","name","toString","lines","concat","worker","Worker","Blob","Buffer","from","join","URL","createObjectURL","type","addEventListener","createFauxWorker","minion","terminated","postMessage","setTimeout","terminate","Processor","constructor","_imageOps","threads","workers","_onWorkerMessage","bind","_workers","_queue","_maxQueueLength","queue","Infinity","_running","_dataLookup","_job","process","inputs","callback","_enqueue","_dispatch","job","push","shift","input","segmentLength","Math","ceil","offset","slices","jj","slice","index","event","disposed","_resolveJob","disposeInternal","RasterEventType","BEFOREOPERATIONS","AFTEROPERATIONS","RasterSourceEvent","frameState","extent","resolution","viewState","pixelRatio","RasterSource","options","projection","on","once","un","processor_","operationType_","operationType","undefined","threads_","layers_","createLayers","sources","changed","ii","CHANGE","useResolutions_","resolutions","tileQueue_","processSources_","requestedFrameState_","renderedImageCanvas_","renderedRevision_","frameState_","animate","coordinateToPixelTransform","declutterTree","layerIndex","layerStatesArray","getLayerStatesArray","pixelToCoordinateTransform","postRenderFunctions","size","tileQueue","time","Date","now","usedTiles","rotation","viewHints","wantedTiles","mapId","renderTargets","setAttributions","attributions","iMax","sourceOrLayer","source","getSource","attributionGetter","getAttributions","sourceAttribution","apply","setOperation","dispose","updateFrameState_","assign","center","allSourcesReady_","ready","getState","getImage","loadMoreTiles","findNearestResolution","renderedResolution","getResolution","renderedExtent","getExtent","getRevision","requestAnimationFrame","len","imageDatas","getImageData","dispatchEvent","onWorkerComplete_","err","round","canvas","putImageData","getResolutions","prototype","sharedContext","layer","renderer","getRenderer","Error","prepareFrame","container","renderFrame","element","HTMLCanvasElement","firstElementChild","willReadFrequently","clearRect","drawImage","layers","getLayerState","createLayer","layerOrSource"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/source/Raster.js"],"sourcesContent":["/**\n * @module ol/source/Raster\n */\nimport Disposable from '../Disposable.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ImageCanvas from '../ImageCanvas.js';\nimport ImageLayer from '../layer/Image.js';\nimport ImageSource from './Image.js';\nimport Source from './Source.js';\nimport TileLayer from '../layer/Tile.js';\nimport TileQueue from '../TileQueue.js';\nimport TileSource from './Tile.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {create as createTransform} from '../transform.js';\nimport {equals, getCenter, getHeight, getWidth} from '../extent.js';\nimport {getUid} from '../util.js';\n\nlet hasImageData = true;\ntry {\n  new ImageData(10, 10);\n} catch (_) {\n  hasImageData = false;\n}\n\n/** @type {CanvasRenderingContext2D} */\nlet context;\n\n/**\n * @param {Uint8ClampedArray} data Image data.\n * @param {number} width Number of columns.\n * @param {number} height Number of rows.\n * @return {ImageData} Image data.\n */\nexport function newImageData(data, width, height) {\n  if (hasImageData) {\n    return new ImageData(data, width, height);\n  }\n\n  if (!context) {\n    context = document.createElement('canvas').getContext('2d');\n  }\n  const imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  return imageData;\n}\n\n/**\n * @typedef {Object} MinionData\n * @property {Array<ArrayBuffer>} buffers Array of buffers.\n * @property {Object} meta Operation metadata.\n * @property {boolean} imageOps The operation is an image operation.\n * @property {number} width The width of the image.\n * @property {number} height The height of the image.\n */\n\n/* istanbul ignore next */\n/**\n * Create a function for running operations.  This function is serialized for\n * use in a worker.\n * @param {function(Array, Object):*} operation The operation.\n * @return {function(MinionData):ArrayBuffer} A function that takes an object with\n * buffers, meta, imageOps, width, and height properties and returns an array\n * buffer.\n */\nfunction createMinion(operation) {\n  let workerHasImageData = true;\n  try {\n    new ImageData(10, 10);\n  } catch (_) {\n    workerHasImageData = false;\n  }\n\n  function newWorkerImageData(data, width, height) {\n    if (workerHasImageData) {\n      return new ImageData(data, width, height);\n    }\n    return {data: data, width: width, height: height};\n  }\n\n  return function (data) {\n    // bracket notation for minification support\n    const buffers = data['buffers'];\n    const meta = data['meta'];\n    const imageOps = data['imageOps'];\n    const width = data['width'];\n    const height = data['height'];\n\n    const numBuffers = buffers.length;\n    const numBytes = buffers[0].byteLength;\n\n    if (imageOps) {\n      const images = new Array(numBuffers);\n      for (let b = 0; b < numBuffers; ++b) {\n        images[b] = newWorkerImageData(\n          new Uint8ClampedArray(buffers[b]),\n          width,\n          height\n        );\n      }\n      const output = operation(images, meta).data;\n      return output.buffer;\n    }\n\n    const output = new Uint8ClampedArray(numBytes);\n    const arrays = new Array(numBuffers);\n    const pixels = new Array(numBuffers);\n    for (let b = 0; b < numBuffers; ++b) {\n      arrays[b] = new Uint8ClampedArray(buffers[b]);\n      pixels[b] = [0, 0, 0, 0];\n    }\n    for (let i = 0; i < numBytes; i += 4) {\n      for (let j = 0; j < numBuffers; ++j) {\n        const array = arrays[j];\n        pixels[j][0] = array[i];\n        pixels[j][1] = array[i + 1];\n        pixels[j][2] = array[i + 2];\n        pixels[j][3] = array[i + 3];\n      }\n      const pixel = operation(pixels, meta);\n      output[i] = pixel[0];\n      output[i + 1] = pixel[1];\n      output[i + 2] = pixel[2];\n      output[i + 3] = pixel[3];\n    }\n    return output.buffer;\n  };\n}\n\n/**\n * Create a worker for running operations.\n * @param {ProcessorOptions} config Processor options.\n * @param {function(MessageEvent): void} onMessage Called with a message event.\n * @return {Worker} The worker.\n */\nfunction createWorker(config, onMessage) {\n  const lib = Object.keys(config.lib || {}).map(function (name) {\n    return 'const ' + name + ' = ' + config.lib[name].toString() + ';';\n  });\n\n  const lines = lib.concat([\n    'const __minion__ = (' + createMinion.toString() + ')(',\n    config.operation.toString(),\n    ');',\n    'self.addEventListener(\"message\", function(event) {',\n    '  const buffer = __minion__(event.data);',\n    '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);',\n    '});',\n  ]);\n\n  const worker = new Worker(\n    typeof Blob === 'undefined'\n      ? 'data:text/javascript;base64,' +\n        Buffer.from(lines.join('\\n'), 'binary').toString('base64')\n      : URL.createObjectURL(new Blob(lines, {type: 'text/javascript'}))\n  );\n  worker.addEventListener('message', onMessage);\n  return worker;\n}\n\n/**\n * @typedef {Object} FauxMessageEvent\n * @property {Object} data Message data.\n */\n\n/**\n * Create a faux worker for running operations.\n * @param {ProcessorOptions} config Configuration.\n * @param {function(FauxMessageEvent): void} onMessage Called with a message event.\n * @return {Object} The faux worker.\n */\nfunction createFauxWorker(config, onMessage) {\n  const minion = createMinion(config.operation);\n  let terminated = false;\n  return {\n    postMessage: function (data) {\n      setTimeout(function () {\n        if (terminated) {\n          return;\n        }\n        onMessage({data: {buffer: minion(data), meta: data['meta']}});\n      }, 0);\n    },\n    terminate: function () {\n      terminated = true;\n    },\n  };\n}\n\n/**\n * @typedef {function(Error, ImageData, (Object|Array<Object>)): void} JobCallback\n */\n\n/**\n * @typedef {Object} Job\n * @property {Object} meta Job metadata.\n * @property {Array<ImageData>} inputs Array of input data.\n * @property {JobCallback} callback Called when the job is complete.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {number} threads Number of workers to spawn.\n * @property {Operation} operation The operation.\n * @property {Object<string, Function>} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} queue The number of queued jobs to allow.\n * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.\n */\n\n/**\n * @classdesc\n * A processor runs pixel or image operations in workers.\n */\nexport class Processor extends Disposable {\n  /**\n   * @param {ProcessorOptions} config Configuration.\n   */\n  constructor(config) {\n    super();\n\n    this._imageOps = !!config.imageOps;\n    let threads;\n    if (config.threads === 0) {\n      threads = 0;\n    } else if (this._imageOps) {\n      threads = 1;\n    } else {\n      threads = config.threads || 1;\n    }\n\n    /**\n     * @type {Array<Worker>}\n     */\n    const workers = new Array(threads);\n    if (threads) {\n      for (let i = 0; i < threads; ++i) {\n        workers[i] = createWorker(config, this._onWorkerMessage.bind(this, i));\n      }\n    } else {\n      workers[0] = createFauxWorker(\n        config,\n        this._onWorkerMessage.bind(this, 0)\n      );\n    }\n    this._workers = workers;\n\n    /**\n     * @type {Array<Job>}\n     * @private\n     */\n    this._queue = [];\n\n    this._maxQueueLength = config.queue || Infinity;\n    this._running = 0;\n\n    /**\n     * @type {Object<number, any>}\n     * @private\n     */\n    this._dataLookup = {};\n\n    /**\n     * @type {Job}\n     * @private\n     */\n    this._job = null;\n  }\n\n  /**\n   * Run operation on input data.\n   * @param {Array<ImageData>} inputs Array of image data.\n   * @param {Object} meta A user data object.  This is passed to all operations\n   *     and must be serializable.\n   * @param {function(Error, ImageData, Object): void} callback Called when work\n   *     completes.  The first argument is any error.  The second is the ImageData\n   *     generated by operations.  The third is the user data object.\n   */\n  process(inputs, meta, callback) {\n    this._enqueue({\n      inputs: inputs,\n      meta: meta,\n      callback: callback,\n    });\n    this._dispatch();\n  }\n\n  /**\n   * Add a job to the queue.\n   * @param {Job} job The job.\n   */\n  _enqueue(job) {\n    this._queue.push(job);\n    while (this._queue.length > this._maxQueueLength) {\n      this._queue.shift().callback(null, null);\n    }\n  }\n\n  /**\n   * Dispatch a job.\n   */\n  _dispatch() {\n    if (this._running || this._queue.length === 0) {\n      return;\n    }\n\n    const job = this._queue.shift();\n    this._job = job;\n    const width = job.inputs[0].width;\n    const height = job.inputs[0].height;\n    const buffers = job.inputs.map(function (input) {\n      return input.data.buffer;\n    });\n    const threads = this._workers.length;\n    this._running = threads;\n    if (threads === 1) {\n      this._workers[0].postMessage(\n        {\n          buffers: buffers,\n          meta: job.meta,\n          imageOps: this._imageOps,\n          width: width,\n          height: height,\n        },\n        buffers\n      );\n      return;\n    }\n\n    const length = job.inputs[0].data.length;\n    const segmentLength = 4 * Math.ceil(length / 4 / threads);\n    for (let i = 0; i < threads; ++i) {\n      const offset = i * segmentLength;\n      const slices = [];\n      for (let j = 0, jj = buffers.length; j < jj; ++j) {\n        slices.push(buffers[j].slice(offset, offset + segmentLength));\n      }\n      this._workers[i].postMessage(\n        {\n          buffers: slices,\n          meta: job.meta,\n          imageOps: this._imageOps,\n          width: width,\n          height: height,\n        },\n        slices\n      );\n    }\n  }\n\n  /**\n   * Handle messages from the worker.\n   * @param {number} index The worker index.\n   * @param {MessageEvent} event The message event.\n   */\n  _onWorkerMessage(index, event) {\n    if (this.disposed) {\n      return;\n    }\n    this._dataLookup[index] = event.data;\n    --this._running;\n    if (this._running === 0) {\n      this._resolveJob();\n    }\n  }\n\n  /**\n   * Resolve a job.  If there are no more worker threads, the processor callback\n   * will be called.\n   */\n  _resolveJob() {\n    const job = this._job;\n    const threads = this._workers.length;\n    let data, meta;\n    if (threads === 1) {\n      data = new Uint8ClampedArray(this._dataLookup[0]['buffer']);\n      meta = this._dataLookup[0]['meta'];\n    } else {\n      const length = job.inputs[0].data.length;\n      data = new Uint8ClampedArray(length);\n      meta = new Array(threads);\n      const segmentLength = 4 * Math.ceil(length / 4 / threads);\n      for (let i = 0; i < threads; ++i) {\n        const buffer = this._dataLookup[i]['buffer'];\n        const offset = i * segmentLength;\n        data.set(new Uint8ClampedArray(buffer), offset);\n        meta[i] = this._dataLookup[i]['meta'];\n      }\n    }\n    this._job = null;\n    this._dataLookup = {};\n    job.callback(\n      null,\n      newImageData(data, job.inputs[0].width, job.inputs[0].height),\n      meta\n    );\n    this._dispatch();\n  }\n\n  /**\n   * Terminate all workers associated with the processor.\n   */\n  disposeInternal() {\n    for (let i = 0; i < this._workers.length; ++i) {\n      this._workers[i].terminate();\n    }\n    this._workers.length = 0;\n  }\n}\n\n/**\n * A function that takes an array of input data, performs some operation, and\n * returns an array of output data.\n * For `pixel` type operations, the function will be called with an array of\n * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the\n * range of 0 - 255. It should return a single pixel array.\n * For `'image'` type operations, functions will be called with an array of\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)\n * and should return a single\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n * The operations\n * are called with a second \"data\" argument, which can be used for storage.  The\n * data object is accessible from raster events, where it can be initialized in\n * \"beforeoperations\" and accessed again in \"afteroperations\".\n *\n * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):\n *     (Array<number>|ImageData)} Operation\n */\n\n/**\n * @enum {string}\n */\nconst RasterEventType = {\n  /**\n   * Triggered before operations are run.  Listeners will receive an event object with\n   * a `data` property that can be used to make data available to operations.\n   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations\n   * @api\n   */\n  BEFOREOPERATIONS: 'beforeoperations',\n\n  /**\n   * Triggered after operations are run.  Listeners will receive an event object with\n   * a `data` property.  If more than one thread is used, `data` will be an array of\n   * objects.  If a single thread is used, `data` will be a single object.\n   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations\n   * @api\n   */\n  AFTEROPERATIONS: 'afteroperations',\n};\n\n/**\n * @typedef {'pixel' | 'image'} RasterOperationType\n * Raster operation type. Supported values are `'pixel'` and `'image'`.\n */\n\n/**\n * @typedef {import(\"./Image.js\").ImageSourceEventTypes|'beforeoperations'|'afteroperations'} RasterSourceEventTypes\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Raster~RasterSource} instances are instances of this\n * type.\n */\nexport class RasterSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Object|Array<Object>} data An object made available to operations.  For \"afteroperations\" evenets\n   * this will be an array of objects if more than one thread is used.\n   */\n  constructor(type, frameState, data) {\n    super(type);\n\n    /**\n     * The raster extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = frameState.extent;\n\n    /**\n     * The pixel resolution (map units per pixel).\n     * @type {number}\n     * @api\n     */\n    this.resolution = frameState.viewState.resolution / frameState.pixelRatio;\n\n    /**\n     * An object made available to all operations.  This can be used by operations\n     * as a storage object (e.g. for calculating statistics).\n     * @type {Object}\n     * @api\n     */\n    this.data = data;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources Input\n * sources or layers.  For vector data, use an VectorImage layer.\n * @property {Operation} [operation] Raster operation.\n * The operation will be called with data from input sources\n * and the output will be assigned to the raster source.\n * @property {Object} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} [threads] By default, operations will be run in a single worker thread.\n * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can\n * be run in multiple worker threads.  Note that there is additional overhead in\n * transferring data to multiple workers, and that depending on the user's\n * system, it may not be possible to parallelize the work.\n * @property {RasterOperationType} [operationType='pixel'] Operation type.\n * Supported values are `'pixel'` and `'image'`.  By default,\n * `'pixel'` operations are assumed, and operations will be called with an\n * array of pixels from input sources.  If set to `'image'`, operations will\n * be called with an array of ImageData objects from input sources.\n * @property {Array<number>|null} [resolutions] Resolutions. If specified, raster operations will only\n * be run at the given resolutions.  By default, the resolutions of the first source with resolutions\n * specified will be used, if any. Set to `null` to use any view resolution instead.\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Image.js\").ImageSourceEventTypes, import(\"./Image.js\").ImageSourceEvent, Return> &\n *   import(\"../Observable\").OnSignature<RasterSourceEventTypes, RasterSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\n *     |RasterSourceEventTypes, Return>} RasterSourceOnSignature\n */\n\n/**\n * @classdesc\n * A source that transforms data from any number of input sources using an\n * {@link module:ol/source/Raster~Operation} function to transform input pixel values into\n * output pixel values.\n *\n * @fires module:ol/source/Raster.RasterSourceEvent\n * @api\n */\nclass RasterSource extends ImageSource {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super({\n      projection: null,\n    });\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {RasterSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {Processor}\n     */\n    this.processor_ = null;\n\n    /**\n     * @private\n     * @type {RasterOperationType}\n     */\n    this.operationType_ =\n      options.operationType !== undefined ? options.operationType : 'pixel';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threads_ = options.threads !== undefined ? options.threads : 1;\n\n    /**\n     * @private\n     * @type {Array<import(\"../layer/Layer.js\").default>}\n     */\n    this.layers_ = createLayers(options.sources);\n\n    const changed = this.changed.bind(this);\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      this.layers_[i].addEventListener(EventType.CHANGE, changed);\n    }\n\n    /** @type {boolean} */\n    this.useResolutions_ = options.resolutions !== null;\n\n    /**\n     * @private\n     * @type {import(\"../TileQueue.js\").default}\n     */\n    this.tileQueue_ = new TileQueue(function () {\n      return 1;\n    }, this.processSources_.bind(this));\n\n    /**\n     * The most recently requested frame state.\n     * @type {import(\"../Map.js\").FrameState}\n     * @private\n     */\n    this.requestedFrameState_;\n\n    /**\n     * The most recently rendered image canvas.\n     * @type {import(\"../ImageCanvas.js\").default}\n     * @private\n     */\n    this.renderedImageCanvas_ = null;\n\n    /**\n     * The most recently rendered revision.\n     * @type {number}\n     */\n    this.renderedRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").FrameState}\n     */\n    this.frameState_ = {\n      animate: false,\n      coordinateToPixelTransform: createTransform(),\n      declutterTree: null,\n      extent: null,\n      index: 0,\n      layerIndex: 0,\n      layerStatesArray: getLayerStatesArray(this.layers_),\n      pixelRatio: 1,\n      pixelToCoordinateTransform: createTransform(),\n      postRenderFunctions: [],\n      size: [0, 0],\n      tileQueue: this.tileQueue_,\n      time: Date.now(),\n      usedTiles: {},\n      viewState: /** @type {import(\"../View.js\").State} */ ({\n        rotation: 0,\n      }),\n      viewHints: [],\n      wantedTiles: {},\n      mapId: getUid(this),\n      renderTargets: {},\n    };\n\n    this.setAttributions(function (frameState) {\n      const attributions = [];\n      for (\n        let index = 0, iMax = options.sources.length;\n        index < iMax;\n        ++index\n      ) {\n        const sourceOrLayer = options.sources[index];\n        const source =\n          sourceOrLayer instanceof Source\n            ? sourceOrLayer\n            : sourceOrLayer.getSource();\n        if (!source) {\n          continue;\n        }\n        const attributionGetter = source.getAttributions();\n        if (typeof attributionGetter === 'function') {\n          const sourceAttribution = attributionGetter(frameState);\n          attributions.push.apply(attributions, sourceAttribution);\n        }\n      }\n      return attributions.length !== 0 ? attributions : null;\n    });\n\n    if (options.operation !== undefined) {\n      this.setOperation(options.operation, options.lib);\n    }\n  }\n\n  /**\n   * Set the operation.\n   * @param {Operation} operation New operation.\n   * @param {Object} [lib] Functions that will be available to operations run\n   *     in a worker.\n   * @api\n   */\n  setOperation(operation, lib) {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n\n    this.processor_ = new Processor({\n      operation: operation,\n      imageOps: this.operationType_ === 'image',\n      queue: 1,\n      lib: lib,\n      threads: this.threads_,\n    });\n    this.changed();\n  }\n\n  /**\n   * Update the stored frame state.\n   * @param {import(\"../extent.js\").Extent} extent The view extent (in map units).\n   * @param {number} resolution The view resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n   * @return {import(\"../Map.js\").FrameState} The updated frame state.\n   * @private\n   */\n  updateFrameState_(extent, resolution, projection) {\n    const frameState = /** @type {import(\"../Map.js\").FrameState} */ (\n      Object.assign({}, this.frameState_)\n    );\n\n    frameState.viewState = /** @type {import(\"../View.js\").State} */ (\n      Object.assign({}, frameState.viewState)\n    );\n\n    const center = getCenter(extent);\n\n    frameState.size[0] = Math.ceil(getWidth(extent) / resolution);\n    frameState.size[1] = Math.ceil(getHeight(extent) / resolution);\n    frameState.extent = [\n      center[0] - (frameState.size[0] * resolution) / 2,\n      center[1] - (frameState.size[1] * resolution) / 2,\n      center[0] + (frameState.size[0] * resolution) / 2,\n      center[1] + (frameState.size[1] * resolution) / 2,\n    ];\n    frameState.time = Date.now();\n\n    const viewState = frameState.viewState;\n    viewState.center = center;\n    viewState.projection = projection;\n    viewState.resolution = resolution;\n    return frameState;\n  }\n\n  /**\n   * Determine if all sources are ready.\n   * @return {boolean} All sources are ready.\n   * @private\n   */\n  allSourcesReady_() {\n    let ready = true;\n    let source;\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      source = this.layers_[i].getSource();\n      if (!source || source.getState() !== 'ready') {\n        ready = false;\n        break;\n      }\n    }\n    return ready;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\n   */\n  getImage(extent, resolution, pixelRatio, projection) {\n    if (!this.allSourcesReady_()) {\n      return null;\n    }\n\n    this.tileQueue_.loadMoreTiles(16, 16);\n\n    resolution = this.findNearestResolution(resolution);\n    const frameState = this.updateFrameState_(extent, resolution, projection);\n    this.requestedFrameState_ = frameState;\n\n    // check if we can't reuse the existing ol/ImageCanvas\n    if (this.renderedImageCanvas_) {\n      const renderedResolution = this.renderedImageCanvas_.getResolution();\n      const renderedExtent = this.renderedImageCanvas_.getExtent();\n      if (\n        resolution !== renderedResolution ||\n        !equals(frameState.extent, renderedExtent)\n      ) {\n        this.renderedImageCanvas_ = null;\n      }\n    }\n\n    if (\n      !this.renderedImageCanvas_ ||\n      this.getRevision() !== this.renderedRevision_\n    ) {\n      this.processSources_();\n    }\n\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    }\n\n    return this.renderedImageCanvas_;\n  }\n\n  /**\n   * Start processing source data.\n   * @private\n   */\n  processSources_() {\n    const frameState = this.requestedFrameState_;\n    const len = this.layers_.length;\n    const imageDatas = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      frameState.layerIndex = i;\n      frameState.renderTargets = {};\n      const imageData = getImageData(this.layers_[i], frameState);\n      if (imageData) {\n        imageDatas[i] = imageData;\n      } else {\n        return;\n      }\n    }\n\n    const data = {};\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data)\n    );\n    this.processor_.process(\n      imageDatas,\n      data,\n      this.onWorkerComplete_.bind(this, frameState)\n    );\n  }\n\n  /**\n   * Called when pixel processing is complete.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Error} err Any error during processing.\n   * @param {ImageData} output The output image data.\n   * @param {Object|Array<Object>} data The user data (or an array if more than one thread).\n   * @private\n   */\n  onWorkerComplete_(frameState, err, output, data) {\n    if (err || !output) {\n      return;\n    }\n\n    // do nothing if extent or resolution changed\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    if (\n      resolution !== this.requestedFrameState_.viewState.resolution ||\n      !equals(extent, this.requestedFrameState_.extent)\n    ) {\n      return;\n    }\n\n    let context;\n    if (this.renderedImageCanvas_) {\n      context = this.renderedImageCanvas_.getImage().getContext('2d');\n    } else {\n      const width = Math.round(getWidth(extent) / resolution);\n      const height = Math.round(getHeight(extent) / resolution);\n      context = createCanvasContext2D(width, height);\n      this.renderedImageCanvas_ = new ImageCanvas(\n        extent,\n        resolution,\n        1,\n        context.canvas\n      );\n    }\n    context.putImageData(output, 0, 0);\n\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    } else {\n      this.changed();\n    }\n    this.renderedRevision_ = this.getRevision();\n\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data)\n    );\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   */\n  getResolutions(projection) {\n    if (!this.useResolutions_) {\n      return null;\n    }\n    let resolutions = super.getResolutions();\n    if (!resolutions) {\n      for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n        const source = this.layers_[i].getSource();\n        resolutions = source.getResolutions(projection);\n        if (resolutions) {\n          break;\n        }\n      }\n    }\n    return resolutions;\n  }\n\n  disposeInternal() {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n    super.disposeInternal();\n  }\n}\n\n/**\n * Clean up and unregister the worker.\n * @function\n * @api\n */\nRasterSource.prototype.dispose;\n\n/**\n * A reusable canvas context.\n * @type {CanvasRenderingContext2D}\n * @private\n */\nlet sharedContext = null;\n\n/**\n * Get image data from a layer.\n * @param {import(\"../layer/Layer.js\").default} layer Layer to render.\n * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n * @return {ImageData} The image data.\n */\nfunction getImageData(layer, frameState) {\n  const renderer = layer.getRenderer();\n  if (!renderer) {\n    throw new Error('Unsupported layer type: ' + layer);\n  }\n\n  if (!renderer.prepareFrame(frameState)) {\n    return null;\n  }\n  const width = frameState.size[0];\n  const height = frameState.size[1];\n  if (width === 0 || height === 0) {\n    return null;\n  }\n  const container = renderer.renderFrame(frameState, null);\n  let element;\n  if (container instanceof HTMLCanvasElement) {\n    element = container;\n  } else {\n    if (container) {\n      element = container.firstElementChild;\n    }\n    if (!(element instanceof HTMLCanvasElement)) {\n      throw new Error('Unsupported rendered element: ' + element);\n    }\n    if (element.width === width && element.height === height) {\n      const context = element.getContext('2d');\n      return context.getImageData(0, 0, width, height);\n    }\n  }\n\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(width, height, undefined, {\n      willReadFrequently: true,\n    });\n  } else {\n    const canvas = sharedContext.canvas;\n    if (canvas.width !== width || canvas.height !== height) {\n      sharedContext = createCanvasContext2D(width, height, undefined, {\n        willReadFrequently: true,\n      });\n    } else {\n      sharedContext.clearRect(0, 0, width, height);\n    }\n  }\n  sharedContext.drawImage(element, 0, 0, width, height);\n  return sharedContext.getImageData(0, 0, width, height);\n}\n\n/**\n * Get a list of layer states from a list of layers.\n * @param {Array<import(\"../layer/Layer.js\").default>} layers Layers.\n * @return {Array<import(\"../layer/Layer.js\").State>} The layer states.\n */\nfunction getLayerStatesArray(layers) {\n  return layers.map(function (layer) {\n    return layer.getLayerState();\n  });\n}\n\n/**\n * Create layers for all sources.\n * @param {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources The sources.\n * @return {Array<import(\"../layer/Layer.js\").default>} Array of layers.\n */\nfunction createLayers(sources) {\n  const len = sources.length;\n  const layers = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    layers[i] = createLayer(sources[i]);\n  }\n  return layers;\n}\n\n/**\n * Create a layer for the provided source.\n * @param {import(\"./Source.js\").default|import(\"../layer/Layer.js\").default} layerOrSource The layer or source.\n * @return {import(\"../layer/Layer.js\").default} The layer.\n */\nfunction createLayer(layerOrSource) {\n  // @type {import(\"../layer/Layer.js\").default}\n  let layer;\n  if (layerOrSource instanceof Source) {\n    if (layerOrSource instanceof TileSource) {\n      layer = new TileLayer({source: layerOrSource});\n    } else if (layerOrSource instanceof ImageSource) {\n      layer = new ImageLayer({source: layerOrSource});\n    }\n  } else {\n    layer = layerOrSource;\n  }\n  return layer;\n}\n\nexport default RasterSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}