{"ast":null,"code":"/**\n * @module ol/source/wms\n */\n\nimport { DECIMALS } from './common.js';\nimport { appendParams } from '../uri.js';\nimport { compareVersions } from '../string.js';\nimport { decode } from '../Image.js';\nimport { floor, round } from '../math.js';\nimport { getForViewAndSize, getHeight, getWidth } from '../extent.js';\nimport { get as getProjection } from '../proj.js';\nimport { getRequestExtent } from './Image.js';\n\n/**\n * Default WMS version.\n * @type {string}\n */\nexport const DEFAULT_VERSION = '1.3.0';\n\n/**\n * @const\n * @type {import(\"../size.js\").Size}\n */\nconst GETFEATUREINFO_IMAGE_SIZE = [101, 101];\n\n/**\n * @api\n * @typedef {'carmentaserver' | 'geoserver' | 'mapserver' | 'qgis'} ServerType\n * Set the server type to use implementation-specific parameters beyond the WMS specification.\n *  - `'carmentaserver'`: HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)\n *  - `'geoserver'`: HiDPI support for [GeoServer](https://geoserver.org/)\n *  - `'mapserver'`: HiDPI support for [MapServer](https://mapserver.org/)\n *  - `'qgis'`: HiDPI support for [QGIS](https://qgis.org/)\n */\n\n/**\n * @param {string} baseUrl Base URL.\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {import(\"../size.js\").Size} size Size.\n * @param {import(\"../proj/Projection.js\").default} projection Projection.\n * @param {Object} params WMS params. Will be modified in place.\n * @return {string} Request URL.\n */\nexport function getRequestUrl(baseUrl, extent, size, projection, params) {\n  params['WIDTH'] = size[0];\n  params['HEIGHT'] = size[1];\n  const axisOrientation = projection.getAxisOrientation();\n  let bbox;\n  const v13 = compareVersions(params['VERSION'], '1.3') >= 0;\n  params[v13 ? 'CRS' : 'SRS'] = projection.getCode();\n  if (v13 && axisOrientation.substr(0, 2) == 'ne') {\n    bbox = [extent[1], extent[0], extent[3], extent[2]];\n  } else {\n    bbox = extent;\n  }\n  params['BBOX'] = bbox.join(',');\n  return appendParams( /** @type {string} */baseUrl, params);\n}\n\n/**\n * @param {import(\"../extent\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio pixel ratio.\n * @param {import(\"../proj.js\").Projection} projection Projection.\n * @param {string} url WMS service url.\n * @param {Object} params WMS params.\n * @param {import(\"./wms.js\").ServerType} serverType The type of the remote WMS server.\n * @return {string} Image src.\n */\nexport function getImageSrc(extent, resolution, pixelRatio, projection, url, params, serverType) {\n  params = Object.assign({\n    REQUEST: 'GetMap'\n  }, params);\n  const imageResolution = resolution / pixelRatio;\n  const imageSize = [round(getWidth(extent) / imageResolution, DECIMALS), round(getHeight(extent) / imageResolution, DECIMALS)];\n  if (pixelRatio != 1) {\n    switch (serverType) {\n      case 'geoserver':\n        const dpi = 90 * pixelRatio + 0.5 | 0;\n        if ('FORMAT_OPTIONS' in params) {\n          params['FORMAT_OPTIONS'] += ';dpi:' + dpi;\n        } else {\n          params['FORMAT_OPTIONS'] = 'dpi:' + dpi;\n        }\n        break;\n      case 'mapserver':\n        params['MAP_RESOLUTION'] = 90 * pixelRatio;\n        break;\n      case 'carmentaserver':\n      case 'qgis':\n        params['DPI'] = 90 * pixelRatio;\n        break;\n      default:\n        throw new Error('Unknown `serverType` configured');\n    }\n  }\n  const src = getRequestUrl(url, extent, imageSize, projection, params);\n  return src;\n}\n\n/**\n * @param {Object} params WMS params.\n * @param {string} request WMS `REQUEST`.\n * @return {Object} WMS params with required properties set.\n */\nexport function getRequestParams(params, request) {\n  return Object.assign({\n    'REQUEST': request,\n    'SERVICE': 'WMS',\n    'VERSION': DEFAULT_VERSION,\n    'FORMAT': 'image/png',\n    'STYLES': '',\n    'TRANSPARENT': true\n  }, params);\n}\n\n/**\n * @typedef {Object} LoaderOptions\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\n * the image from the remote server.\n * @property {Object<string,*>} [params] WMS request parameters.\n * At least a `LAYERS` param is required. `STYLES` is\n * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT` and `BBOX` will be set\n * dynamically. `CRS` (`SRS` for WMS version < 1.3.0) will is derived from the `proection` config.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is 'EPSG:3857'.\n * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means\n * twice the width and height of the map viewport, and so on. Must be `1` or higher.\n * @property {import(\"./wms.js\").ServerType} [serverType] The type of\n * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.\n * Only needed if `hidpi` is `true`.\n * @property {string} url WMS service URL.\n * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function\n * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and\n * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.\n */\n\n/**\n * Creates a loader for WMS images.\n * @param {LoaderOptions} options Loader options.\n * @return {import(\"../Image.js\").ImageObjectPromiseLoader} Loader.\n * @api\n */\nexport function createLoader(options) {\n  const hidpi = options.hidpi === undefined ? true : options.hidpi;\n  const projection = getProjection(options.projection || 'EPSG:3857');\n  const ratio = options.ratio || 1.5;\n  const load = options.load || decode;\n\n  /**\n   * @type {import(\"../Image.js\").Loader}\n   */\n  return (extent, resolution, pixelRatio) => {\n    extent = getRequestExtent(extent, resolution, pixelRatio, ratio);\n    if (pixelRatio != 1 && (!hidpi || options.serverType === undefined)) {\n      pixelRatio = 1;\n    }\n    const src = getImageSrc(extent, resolution, pixelRatio, projection, options.url, getRequestParams(options.params, 'GetMap'), options.serverType);\n    const image = new Image();\n    if (options.crossOrigin !== null) {\n      image.crossOrigin = options.crossOrigin;\n    }\n    return load(image, src).then(image => ({\n      image,\n      extent,\n      pixelRatio\n    }));\n  };\n}\n\n/**\n * Get the GetFeatureInfo URL for the passed coordinate and resolution. Returns `undefined` if the\n * GetFeatureInfo URL cannot be constructed.\n * @param {LoaderOptions} options Options passed the `createWMSLoader()` function. In addition to\n * the params required by the loader, `INFO_FORMAT` should be specified, it defaults to\n * `application/json`. If `QUERY_LAYERS` is not provided, then the layers specified in the `LAYERS`\n * parameter will be used.\n * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} resolution Resolution.\n * @return {string|undefined} GetFeatureInfo URL.\n * @api\n */\nexport function getFeatureInfoUrl(options, coordinate, resolution) {\n  if (options.url === undefined) {\n    return undefined;\n  }\n  const projectionObj = getProjection(options.projection || 'EPSG:3857');\n  const extent = getForViewAndSize(coordinate, resolution, 0, GETFEATUREINFO_IMAGE_SIZE);\n  const baseParams = {\n    'QUERY_LAYERS': options.params['LAYERS'],\n    'INFO_FORMAT': 'application/json'\n  };\n  Object.assign(baseParams, getRequestParams(options.params, 'GetFeatureInfo'), options.params);\n  const x = floor((coordinate[0] - extent[0]) / resolution, DECIMALS);\n  const y = floor((extent[3] - coordinate[1]) / resolution, DECIMALS);\n  const v13 = compareVersions(baseParams['VERSION'], '1.3') >= 0;\n  baseParams[v13 ? 'I' : 'X'] = x;\n  baseParams[v13 ? 'J' : 'Y'] = y;\n  return getRequestUrl(options.url, extent, GETFEATUREINFO_IMAGE_SIZE, projectionObj, baseParams);\n}\n\n/**\n * Get the GetLegendGraphic URL, optionally optimized for the passed resolution and possibly\n * including any passed specific parameters. Returns `undefined` if the GetLegendGraphic URL\n * cannot be constructed.\n *\n * @param {LoaderOptions} options Options passed the `createWMSLoader()` function.\n * @param {number} [resolution] Resolution. If not provided, `SCALE` will not be calculated and\n * included in URL.\n * @return {string|undefined} GetLegendGraphic URL.\n * @api\n */\nexport function getLegendUrl(options, resolution) {\n  if (options.url === undefined) {\n    return undefined;\n  }\n  const baseParams = {\n    'SERVICE': 'WMS',\n    'VERSION': DEFAULT_VERSION,\n    'REQUEST': 'GetLegendGraphic',\n    'FORMAT': 'image/png'\n  };\n  if (options.params === undefined || options.params['LAYER'] === undefined) {\n    const layers = options.params.LAYERS;\n    const isSingleLayer = !Array.isArray(layers) || layers.length === 1;\n    if (!isSingleLayer) {\n      return undefined;\n    }\n    baseParams['LAYER'] = layers;\n  }\n  if (resolution !== undefined) {\n    const mpu = getProjection(options.projection || 'EPSG:3857').getMetersPerUnit() || 1;\n    const pixelSize = 0.00028;\n    baseParams['SCALE'] = resolution * mpu / pixelSize;\n  }\n  Object.assign(baseParams, options.params);\n  return appendParams(options.url, baseParams);\n}","map":{"version":3,"names":["DECIMALS","appendParams","compareVersions","decode","floor","round","getForViewAndSize","getHeight","getWidth","get","getProjection","getRequestExtent","DEFAULT_VERSION","GETFEATUREINFO_IMAGE_SIZE","getRequestUrl","baseUrl","extent","size","projection","params","axisOrientation","getAxisOrientation","bbox","v13","getCode","substr","join","getImageSrc","resolution","pixelRatio","url","serverType","Object","assign","REQUEST","imageResolution","imageSize","dpi","Error","src","getRequestParams","request","createLoader","options","hidpi","undefined","ratio","load","image","Image","crossOrigin","then","getFeatureInfoUrl","coordinate","projectionObj","baseParams","x","y","getLegendUrl","layers","LAYERS","isSingleLayer","Array","isArray","length","mpu","getMetersPerUnit","pixelSize"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/source/wms.js"],"sourcesContent":["/**\n * @module ol/source/wms\n */\n\nimport {DECIMALS} from './common.js';\nimport {appendParams} from '../uri.js';\nimport {compareVersions} from '../string.js';\nimport {decode} from '../Image.js';\nimport {floor, round} from '../math.js';\nimport {getForViewAndSize, getHeight, getWidth} from '../extent.js';\nimport {get as getProjection} from '../proj.js';\nimport {getRequestExtent} from './Image.js';\n\n/**\n * Default WMS version.\n * @type {string}\n */\nexport const DEFAULT_VERSION = '1.3.0';\n\n/**\n * @const\n * @type {import(\"../size.js\").Size}\n */\nconst GETFEATUREINFO_IMAGE_SIZE = [101, 101];\n\n/**\n * @api\n * @typedef {'carmentaserver' | 'geoserver' | 'mapserver' | 'qgis'} ServerType\n * Set the server type to use implementation-specific parameters beyond the WMS specification.\n *  - `'carmentaserver'`: HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)\n *  - `'geoserver'`: HiDPI support for [GeoServer](https://geoserver.org/)\n *  - `'mapserver'`: HiDPI support for [MapServer](https://mapserver.org/)\n *  - `'qgis'`: HiDPI support for [QGIS](https://qgis.org/)\n */\n\n/**\n * @param {string} baseUrl Base URL.\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {import(\"../size.js\").Size} size Size.\n * @param {import(\"../proj/Projection.js\").default} projection Projection.\n * @param {Object} params WMS params. Will be modified in place.\n * @return {string} Request URL.\n */\nexport function getRequestUrl(baseUrl, extent, size, projection, params) {\n  params['WIDTH'] = size[0];\n  params['HEIGHT'] = size[1];\n\n  const axisOrientation = projection.getAxisOrientation();\n  let bbox;\n  const v13 = compareVersions(params['VERSION'], '1.3') >= 0;\n  params[v13 ? 'CRS' : 'SRS'] = projection.getCode();\n  if (v13 && axisOrientation.substr(0, 2) == 'ne') {\n    bbox = [extent[1], extent[0], extent[3], extent[2]];\n  } else {\n    bbox = extent;\n  }\n  params['BBOX'] = bbox.join(',');\n\n  return appendParams(/** @type {string} */ (baseUrl), params);\n}\n\n/**\n * @param {import(\"../extent\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio pixel ratio.\n * @param {import(\"../proj.js\").Projection} projection Projection.\n * @param {string} url WMS service url.\n * @param {Object} params WMS params.\n * @param {import(\"./wms.js\").ServerType} serverType The type of the remote WMS server.\n * @return {string} Image src.\n */\nexport function getImageSrc(\n  extent,\n  resolution,\n  pixelRatio,\n  projection,\n  url,\n  params,\n  serverType\n) {\n  params = Object.assign({REQUEST: 'GetMap'}, params);\n\n  const imageResolution = resolution / pixelRatio;\n\n  const imageSize = [\n    round(getWidth(extent) / imageResolution, DECIMALS),\n    round(getHeight(extent) / imageResolution, DECIMALS),\n  ];\n\n  if (pixelRatio != 1) {\n    switch (serverType) {\n      case 'geoserver':\n        const dpi = (90 * pixelRatio + 0.5) | 0;\n        if ('FORMAT_OPTIONS' in params) {\n          params['FORMAT_OPTIONS'] += ';dpi:' + dpi;\n        } else {\n          params['FORMAT_OPTIONS'] = 'dpi:' + dpi;\n        }\n        break;\n      case 'mapserver':\n        params['MAP_RESOLUTION'] = 90 * pixelRatio;\n        break;\n      case 'carmentaserver':\n      case 'qgis':\n        params['DPI'] = 90 * pixelRatio;\n        break;\n      default:\n        throw new Error('Unknown `serverType` configured');\n    }\n  }\n\n  const src = getRequestUrl(url, extent, imageSize, projection, params);\n  return src;\n}\n\n/**\n * @param {Object} params WMS params.\n * @param {string} request WMS `REQUEST`.\n * @return {Object} WMS params with required properties set.\n */\nexport function getRequestParams(params, request) {\n  return Object.assign(\n    {\n      'REQUEST': request,\n      'SERVICE': 'WMS',\n      'VERSION': DEFAULT_VERSION,\n      'FORMAT': 'image/png',\n      'STYLES': '',\n      'TRANSPARENT': true,\n    },\n    params\n  );\n}\n\n/**\n * @typedef {Object} LoaderOptions\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\n * the image from the remote server.\n * @property {Object<string,*>} [params] WMS request parameters.\n * At least a `LAYERS` param is required. `STYLES` is\n * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT` and `BBOX` will be set\n * dynamically. `CRS` (`SRS` for WMS version < 1.3.0) will is derived from the `proection` config.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is 'EPSG:3857'.\n * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means\n * twice the width and height of the map viewport, and so on. Must be `1` or higher.\n * @property {import(\"./wms.js\").ServerType} [serverType] The type of\n * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.\n * Only needed if `hidpi` is `true`.\n * @property {string} url WMS service URL.\n * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function\n * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and\n * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.\n */\n\n/**\n * Creates a loader for WMS images.\n * @param {LoaderOptions} options Loader options.\n * @return {import(\"../Image.js\").ImageObjectPromiseLoader} Loader.\n * @api\n */\nexport function createLoader(options) {\n  const hidpi = options.hidpi === undefined ? true : options.hidpi;\n  const projection = getProjection(options.projection || 'EPSG:3857');\n  const ratio = options.ratio || 1.5;\n  const load = options.load || decode;\n\n  /**\n   * @type {import(\"../Image.js\").Loader}\n   */\n  return (extent, resolution, pixelRatio) => {\n    extent = getRequestExtent(extent, resolution, pixelRatio, ratio);\n    if (pixelRatio != 1 && (!hidpi || options.serverType === undefined)) {\n      pixelRatio = 1;\n    }\n    const src = getImageSrc(\n      extent,\n      resolution,\n      pixelRatio,\n      projection,\n      options.url,\n      getRequestParams(options.params, 'GetMap'),\n      options.serverType\n    );\n    const image = new Image();\n    if (options.crossOrigin !== null) {\n      image.crossOrigin = options.crossOrigin;\n    }\n    return load(image, src).then((image) => ({image, extent, pixelRatio}));\n  };\n}\n\n/**\n * Get the GetFeatureInfo URL for the passed coordinate and resolution. Returns `undefined` if the\n * GetFeatureInfo URL cannot be constructed.\n * @param {LoaderOptions} options Options passed the `createWMSLoader()` function. In addition to\n * the params required by the loader, `INFO_FORMAT` should be specified, it defaults to\n * `application/json`. If `QUERY_LAYERS` is not provided, then the layers specified in the `LAYERS`\n * parameter will be used.\n * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} resolution Resolution.\n * @return {string|undefined} GetFeatureInfo URL.\n * @api\n */\nexport function getFeatureInfoUrl(options, coordinate, resolution) {\n  if (options.url === undefined) {\n    return undefined;\n  }\n\n  const projectionObj = getProjection(options.projection || 'EPSG:3857');\n\n  const extent = getForViewAndSize(\n    coordinate,\n    resolution,\n    0,\n    GETFEATUREINFO_IMAGE_SIZE\n  );\n\n  const baseParams = {\n    'QUERY_LAYERS': options.params['LAYERS'],\n    'INFO_FORMAT': 'application/json',\n  };\n  Object.assign(\n    baseParams,\n    getRequestParams(options.params, 'GetFeatureInfo'),\n    options.params\n  );\n\n  const x = floor((coordinate[0] - extent[0]) / resolution, DECIMALS);\n  const y = floor((extent[3] - coordinate[1]) / resolution, DECIMALS);\n  const v13 = compareVersions(baseParams['VERSION'], '1.3') >= 0;\n  baseParams[v13 ? 'I' : 'X'] = x;\n  baseParams[v13 ? 'J' : 'Y'] = y;\n\n  return getRequestUrl(\n    options.url,\n    extent,\n    GETFEATUREINFO_IMAGE_SIZE,\n    projectionObj,\n    baseParams\n  );\n}\n\n/**\n * Get the GetLegendGraphic URL, optionally optimized for the passed resolution and possibly\n * including any passed specific parameters. Returns `undefined` if the GetLegendGraphic URL\n * cannot be constructed.\n *\n * @param {LoaderOptions} options Options passed the `createWMSLoader()` function.\n * @param {number} [resolution] Resolution. If not provided, `SCALE` will not be calculated and\n * included in URL.\n * @return {string|undefined} GetLegendGraphic URL.\n * @api\n */\nexport function getLegendUrl(options, resolution) {\n  if (options.url === undefined) {\n    return undefined;\n  }\n\n  const baseParams = {\n    'SERVICE': 'WMS',\n    'VERSION': DEFAULT_VERSION,\n    'REQUEST': 'GetLegendGraphic',\n    'FORMAT': 'image/png',\n  };\n\n  if (options.params === undefined || options.params['LAYER'] === undefined) {\n    const layers = options.params.LAYERS;\n    const isSingleLayer = !Array.isArray(layers) || layers.length === 1;\n    if (!isSingleLayer) {\n      return undefined;\n    }\n    baseParams['LAYER'] = layers;\n  }\n\n  if (resolution !== undefined) {\n    const mpu =\n      getProjection(options.projection || 'EPSG:3857').getMetersPerUnit() || 1;\n    const pixelSize = 0.00028;\n    baseParams['SCALE'] = (resolution * mpu) / pixelSize;\n  }\n\n  Object.assign(baseParams, options.params);\n\n  return appendParams(options.url, baseParams);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}