{"ast":null,"code":"/**\n * @module ol/render/webgl/utils\n */\nimport earcut from 'earcut';\nimport { apply as applyTransform } from '../../transform.js';\nimport { clamp } from '../../math.js';\nexport const LINESTRING_ANGLE_COSINE_CUTOFF = 0.985;\n\n/** @type {Array<number>} */\nconst tmpArray_ = [];\n\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\nconst bufferPositions_ = {\n  vertexPosition: 0,\n  indexPosition: 0\n};\n\n/**\n * @param {Float32Array} buffer Buffer\n * @param {number} pos Position\n * @param {number} x X\n * @param {number} y Y\n * @param {number} index Index\n */\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesSize Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesSize, bufferPositions) {\n  // This is for x, y and index\n  const baseVertexAttrsCount = 3;\n  const baseInstructionsCount = 2;\n  const stride = baseVertexAttrsCount + customAttributesSize;\n  const x = instructions[elementIndex + 0];\n  const y = instructions[elementIndex + 1];\n\n  // read custom numerical attributes on the feature\n  const customAttrs = tmpArray_;\n  customAttrs.length = customAttributesSize;\n  for (let i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  const baseIndex = vPos / stride;\n\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n  return bufferPositions_;\n}\n\n/**\n * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next\n * segment, in order to be able to offset the vertices correctly in the shader.\n * Join angles are between 0 and 2PI.\n * This also computes the length of the current segment and the sum of the join angle tangents in order\n * to store this information on each subsequent segment along the line. This is necessary to correctly render dashes\n * and symbols along the line.\n *\n *   pB (before)                          pA (after)\n *    X             negative             X\n *     \\             offset             /\n *      \\                              /\n *       \\   join              join   /\n *        \\ angle 0          angle 1 /\n *         \\←---                ←---/      positive\n *          \\   ←--          ←--   /        offset\n *           \\     ↑       ↓      /\n *            X────┴───────┴─────X\n *            p0                  p1\n *\n * @param {Float32Array} instructions Array of render instructions for lines.s\n * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.\n * @param {number} segmentEndIndex Index of the segment end point from which render instructions will be read.\n * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)\n * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {Array<number>} customAttributes Array of custom attributes value\n * @param {import('../../transform.js').Transform} toWorldTransform Transform matrix used to obtain world coordinates from instructions\n * @param {number} currentLength Cumulated length of segments processed so far\n * @param {number} currentAngleTangentSum Cumulated tangents of the join angles processed so far\n * @return {{length: number, angle: number}} Cumulated length with the newly processed segment (in world units), new sum of the join angle tangents\n * @private\n */\nexport function writeLineSegmentToBuffers(instructions, segmentStartIndex, segmentEndIndex, beforeSegmentIndex, afterSegmentIndex, vertexArray, indexArray, customAttributes, toWorldTransform, currentLength, currentAngleTangentSum) {\n  // compute the stride to determine how many vertices were already pushed\n  const baseVertexAttrsCount = 8; // base attributes: x0, y0, x1, y1, angle0, angle1, distance, params\n  const stride = baseVertexAttrsCount + customAttributes.length;\n  const baseIndex = vertexArray.length / stride;\n\n  // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]\n  // Depending on whether there are points before and after the segment, its final shape\n  // will be different\n  const p0 = [instructions[segmentStartIndex + 0], instructions[segmentStartIndex + 1]];\n  const p1 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]];\n\n  // to compute join angles we need to reproject coordinates back in world units\n  const p0world = applyTransform(toWorldTransform, [...p0]);\n  const p1world = applyTransform(toWorldTransform, [...p1]);\n\n  /**\n   * Compute the angle between p0pA and p0pB\n   * @param {import(\"../../coordinate.js\").Coordinate} p0 Point 0\n   * @param {import(\"../../coordinate.js\").Coordinate} pA Point A\n   * @param {import(\"../../coordinate.js\").Coordinate} pB Point B\n   * @return {number} a value in [0, 2PI]\n   */\n  function angleBetween(p0, pA, pB) {\n    const lenA = Math.sqrt((pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1]));\n    const tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];\n    const orthoA = [-tangentA[1], tangentA[0]];\n    const lenB = Math.sqrt((pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1]));\n    const tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB];\n\n    // this angle can be clockwise or anticlockwise; hence the computation afterwards\n    const angle = lenA === 0 || lenB === 0 ? 0 : Math.acos(clamp(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1));\n    const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;\n    return !isClockwise ? Math.PI * 2 - angle : angle;\n  }\n\n  // a negative angle indicates a line cap\n  let angle0 = -1;\n  let angle1 = -1;\n  let newAngleTangentSum = currentAngleTangentSum;\n  const joinBefore = beforeSegmentIndex !== null;\n  const joinAfter = afterSegmentIndex !== null;\n\n  // add vertices and adapt offsets for P0 in case of join\n  if (joinBefore) {\n    // B for before\n    const pB = [instructions[beforeSegmentIndex], instructions[beforeSegmentIndex + 1]];\n    const pBworld = applyTransform(toWorldTransform, [...pB]);\n    angle0 = angleBetween(p0world, p1world, pBworld);\n\n    // only add to the sum if the angle isn't too close to 0 or 2PI\n    if (Math.cos(angle0) <= LINESTRING_ANGLE_COSINE_CUTOFF) {\n      newAngleTangentSum += Math.tan((angle0 - Math.PI) / 2);\n    }\n  }\n  // adapt offsets for P1 in case of join; add to angle sum\n  if (joinAfter) {\n    // A for after\n    const pA = [instructions[afterSegmentIndex], instructions[afterSegmentIndex + 1]];\n    const pAworld = applyTransform(toWorldTransform, [...pA]);\n    angle1 = angleBetween(p1world, p0world, pAworld);\n\n    // only add to the sum if the angle isn't too close to 0 or 2PI\n    if (Math.cos(angle1) <= LINESTRING_ANGLE_COSINE_CUTOFF) {\n      newAngleTangentSum += Math.tan((Math.PI - angle1) / 2);\n    }\n  }\n\n  /**\n   * @param {number} vertexIndex From 0 to 3, indicating position in the quad\n   * @param {number} angleSum Sum of the join angles encountered so far (used to compute distance offset\n   * @return {number} A float value containing both information\n   */\n  function computeParameters(vertexIndex, angleSum) {\n    if (angleSum === 0) {\n      return vertexIndex * 10000;\n    }\n    return Math.sign(angleSum) * (vertexIndex * 10000 + Math.abs(angleSum));\n  }\n\n  // add main segment triangles\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, computeParameters(0, currentAngleTangentSum));\n  vertexArray.push(...customAttributes);\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, computeParameters(1, currentAngleTangentSum));\n  vertexArray.push(...customAttributes);\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, computeParameters(2, currentAngleTangentSum));\n  vertexArray.push(...customAttributes);\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, computeParameters(3, currentAngleTangentSum));\n  vertexArray.push(...customAttributes);\n  indexArray.push(baseIndex, baseIndex + 1, baseIndex + 2, baseIndex + 1, baseIndex + 3, baseIndex + 2);\n  return {\n    length: currentLength + Math.sqrt((p1world[0] - p0world[0]) * (p1world[0] - p0world[0]) + (p1world[1] - p0world[1]) * (p1world[1] - p0world[1])),\n    angle: newAngleTangentSum\n  };\n}\n\n/**\n * Pushes several triangles to form a polygon, including holes\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {number} customAttributesSize Amount of custom attributes for each element.\n * @return {number} Next polygon instructions index\n * @private\n */\nexport function writePolygonTrianglesToBuffers(instructions, polygonStartIndex, vertexArray, indexArray, customAttributesSize) {\n  const instructionsPerVertex = 2; // x, y\n  const attributesPerVertex = 2 + customAttributesSize;\n  let instructionsIndex = polygonStartIndex;\n  const customAttributes = instructions.slice(instructionsIndex, instructionsIndex + customAttributesSize);\n  instructionsIndex += customAttributesSize;\n  const ringsCount = instructions[instructionsIndex++];\n  let verticesCount = 0;\n  const holes = new Array(ringsCount - 1);\n  for (let i = 0; i < ringsCount; i++) {\n    verticesCount += instructions[instructionsIndex++];\n    if (i < ringsCount - 1) {\n      holes[i] = verticesCount;\n    }\n  }\n  const flatCoords = instructions.slice(instructionsIndex, instructionsIndex + verticesCount * instructionsPerVertex);\n\n  // pushing to vertices and indices!! this is where the magic happens\n  const result = earcut(flatCoords, holes, instructionsPerVertex);\n  for (let i = 0; i < result.length; i++) {\n    indexArray.push(result[i] + vertexArray.length / attributesPerVertex);\n  }\n  for (let i = 0; i < flatCoords.length; i += 2) {\n    vertexArray.push(flatCoords[i], flatCoords[i + 1], ...customAttributes);\n  }\n  return instructionsIndex + verticesCount * instructionsPerVertex;\n}\n\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n  const canvas = document.createElement('canvas');\n  const image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, array) {\n  array = array || [];\n  const radix = 256;\n  const divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = Math.floor(id / radix / radix) % radix / divide;\n  array[2] = Math.floor(id / radix) % radix / divide;\n  array[3] = id % radix / divide;\n  return array;\n}\n\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n  let id = 0;\n  const radix = 256;\n  const mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}","map":{"version":3,"names":["earcut","apply","applyTransform","clamp","LINESTRING_ANGLE_COSINE_CUTOFF","tmpArray_","bufferPositions_","vertexPosition","indexPosition","writePointVertex","buffer","pos","x","y","index","writePointFeatureToBuffers","instructions","elementIndex","vertexBuffer","indexBuffer","customAttributesSize","bufferPositions","baseVertexAttrsCount","baseInstructionsCount","stride","customAttrs","length","i","vPos","iPos","baseIndex","set","writeLineSegmentToBuffers","segmentStartIndex","segmentEndIndex","beforeSegmentIndex","afterSegmentIndex","vertexArray","indexArray","customAttributes","toWorldTransform","currentLength","currentAngleTangentSum","p0","p1","p0world","p1world","angleBetween","pA","pB","lenA","Math","sqrt","tangentA","orthoA","lenB","tangentB","angle","acos","isClockwise","PI","angle0","angle1","newAngleTangentSum","joinBefore","joinAfter","pBworld","cos","tan","pAworld","computeParameters","vertexIndex","angleSum","sign","abs","push","writePolygonTrianglesToBuffers","polygonStartIndex","instructionsPerVertex","attributesPerVertex","instructionsIndex","slice","ringsCount","verticesCount","holes","Array","flatCoords","result","getBlankImageData","canvas","document","createElement","image","getContext","createImageData","data","colorEncodeId","id","array","radix","divide","floor","colorDecodeId","color","mult","round"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/render/webgl/utils.js"],"sourcesContent":["/**\n * @module ol/render/webgl/utils\n */\nimport earcut from 'earcut';\nimport {apply as applyTransform} from '../../transform.js';\nimport {clamp} from '../../math.js';\n\nexport const LINESTRING_ANGLE_COSINE_CUTOFF = 0.985;\n\n/** @type {Array<number>} */\nconst tmpArray_ = [];\n\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\nconst bufferPositions_ = {vertexPosition: 0, indexPosition: 0};\n\n/**\n * @param {Float32Array} buffer Buffer\n * @param {number} pos Position\n * @param {number} x X\n * @param {number} y Y\n * @param {number} index Index\n */\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesSize Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(\n  instructions,\n  elementIndex,\n  vertexBuffer,\n  indexBuffer,\n  customAttributesSize,\n  bufferPositions\n) {\n  // This is for x, y and index\n  const baseVertexAttrsCount = 3;\n  const baseInstructionsCount = 2;\n  const stride = baseVertexAttrsCount + customAttributesSize;\n\n  const x = instructions[elementIndex + 0];\n  const y = instructions[elementIndex + 1];\n\n  // read custom numerical attributes on the feature\n  const customAttrs = tmpArray_;\n  customAttrs.length = customAttributesSize;\n  for (let i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n\n  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  const baseIndex = vPos / stride;\n\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n\n  return bufferPositions_;\n}\n\n/**\n * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next\n * segment, in order to be able to offset the vertices correctly in the shader.\n * Join angles are between 0 and 2PI.\n * This also computes the length of the current segment and the sum of the join angle tangents in order\n * to store this information on each subsequent segment along the line. This is necessary to correctly render dashes\n * and symbols along the line.\n *\n *   pB (before)                          pA (after)\n *    X             negative             X\n *     \\             offset             /\n *      \\                              /\n *       \\   join              join   /\n *        \\ angle 0          angle 1 /\n *         \\←---                ←---/      positive\n *          \\   ←--          ←--   /        offset\n *           \\     ↑       ↓      /\n *            X────┴───────┴─────X\n *            p0                  p1\n *\n * @param {Float32Array} instructions Array of render instructions for lines.s\n * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.\n * @param {number} segmentEndIndex Index of the segment end point from which render instructions will be read.\n * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)\n * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {Array<number>} customAttributes Array of custom attributes value\n * @param {import('../../transform.js').Transform} toWorldTransform Transform matrix used to obtain world coordinates from instructions\n * @param {number} currentLength Cumulated length of segments processed so far\n * @param {number} currentAngleTangentSum Cumulated tangents of the join angles processed so far\n * @return {{length: number, angle: number}} Cumulated length with the newly processed segment (in world units), new sum of the join angle tangents\n * @private\n */\nexport function writeLineSegmentToBuffers(\n  instructions,\n  segmentStartIndex,\n  segmentEndIndex,\n  beforeSegmentIndex,\n  afterSegmentIndex,\n  vertexArray,\n  indexArray,\n  customAttributes,\n  toWorldTransform,\n  currentLength,\n  currentAngleTangentSum\n) {\n  // compute the stride to determine how many vertices were already pushed\n  const baseVertexAttrsCount = 8; // base attributes: x0, y0, x1, y1, angle0, angle1, distance, params\n  const stride = baseVertexAttrsCount + customAttributes.length;\n  const baseIndex = vertexArray.length / stride;\n\n  // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]\n  // Depending on whether there are points before and after the segment, its final shape\n  // will be different\n  const p0 = [\n    instructions[segmentStartIndex + 0],\n    instructions[segmentStartIndex + 1],\n  ];\n  const p1 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]];\n\n  // to compute join angles we need to reproject coordinates back in world units\n  const p0world = applyTransform(toWorldTransform, [...p0]);\n  const p1world = applyTransform(toWorldTransform, [...p1]);\n\n  /**\n   * Compute the angle between p0pA and p0pB\n   * @param {import(\"../../coordinate.js\").Coordinate} p0 Point 0\n   * @param {import(\"../../coordinate.js\").Coordinate} pA Point A\n   * @param {import(\"../../coordinate.js\").Coordinate} pB Point B\n   * @return {number} a value in [0, 2PI]\n   */\n  function angleBetween(p0, pA, pB) {\n    const lenA = Math.sqrt(\n      (pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1])\n    );\n    const tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];\n    const orthoA = [-tangentA[1], tangentA[0]];\n    const lenB = Math.sqrt(\n      (pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1])\n    );\n    const tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB];\n\n    // this angle can be clockwise or anticlockwise; hence the computation afterwards\n    const angle =\n      lenA === 0 || lenB === 0\n        ? 0\n        : Math.acos(\n            clamp(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1)\n          );\n    const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;\n    return !isClockwise ? Math.PI * 2 - angle : angle;\n  }\n\n  // a negative angle indicates a line cap\n  let angle0 = -1;\n  let angle1 = -1;\n  let newAngleTangentSum = currentAngleTangentSum;\n\n  const joinBefore = beforeSegmentIndex !== null;\n  const joinAfter = afterSegmentIndex !== null;\n\n  // add vertices and adapt offsets for P0 in case of join\n  if (joinBefore) {\n    // B for before\n    const pB = [\n      instructions[beforeSegmentIndex],\n      instructions[beforeSegmentIndex + 1],\n    ];\n    const pBworld = applyTransform(toWorldTransform, [...pB]);\n    angle0 = angleBetween(p0world, p1world, pBworld);\n\n    // only add to the sum if the angle isn't too close to 0 or 2PI\n    if (Math.cos(angle0) <= LINESTRING_ANGLE_COSINE_CUTOFF) {\n      newAngleTangentSum += Math.tan((angle0 - Math.PI) / 2);\n    }\n  }\n  // adapt offsets for P1 in case of join; add to angle sum\n  if (joinAfter) {\n    // A for after\n    const pA = [\n      instructions[afterSegmentIndex],\n      instructions[afterSegmentIndex + 1],\n    ];\n    const pAworld = applyTransform(toWorldTransform, [...pA]);\n    angle1 = angleBetween(p1world, p0world, pAworld);\n\n    // only add to the sum if the angle isn't too close to 0 or 2PI\n    if (Math.cos(angle1) <= LINESTRING_ANGLE_COSINE_CUTOFF) {\n      newAngleTangentSum += Math.tan((Math.PI - angle1) / 2);\n    }\n  }\n\n  /**\n   * @param {number} vertexIndex From 0 to 3, indicating position in the quad\n   * @param {number} angleSum Sum of the join angles encountered so far (used to compute distance offset\n   * @return {number} A float value containing both information\n   */\n  function computeParameters(vertexIndex, angleSum) {\n    if (angleSum === 0) {\n      return vertexIndex * 10000;\n    }\n    return Math.sign(angleSum) * (vertexIndex * 10000 + Math.abs(angleSum));\n  }\n\n  // add main segment triangles\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    angle0,\n    angle1,\n    currentLength,\n    computeParameters(0, currentAngleTangentSum)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    angle0,\n    angle1,\n    currentLength,\n    computeParameters(1, currentAngleTangentSum)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    angle0,\n    angle1,\n    currentLength,\n    computeParameters(2, currentAngleTangentSum)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    angle0,\n    angle1,\n    currentLength,\n    computeParameters(3, currentAngleTangentSum)\n  );\n  vertexArray.push(...customAttributes);\n\n  indexArray.push(\n    baseIndex,\n    baseIndex + 1,\n    baseIndex + 2,\n    baseIndex + 1,\n    baseIndex + 3,\n    baseIndex + 2\n  );\n\n  return {\n    length:\n      currentLength +\n      Math.sqrt(\n        (p1world[0] - p0world[0]) * (p1world[0] - p0world[0]) +\n          (p1world[1] - p0world[1]) * (p1world[1] - p0world[1])\n      ),\n    angle: newAngleTangentSum,\n  };\n}\n\n/**\n * Pushes several triangles to form a polygon, including holes\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {number} customAttributesSize Amount of custom attributes for each element.\n * @return {number} Next polygon instructions index\n * @private\n */\nexport function writePolygonTrianglesToBuffers(\n  instructions,\n  polygonStartIndex,\n  vertexArray,\n  indexArray,\n  customAttributesSize\n) {\n  const instructionsPerVertex = 2; // x, y\n  const attributesPerVertex = 2 + customAttributesSize;\n  let instructionsIndex = polygonStartIndex;\n  const customAttributes = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + customAttributesSize\n  );\n  instructionsIndex += customAttributesSize;\n  const ringsCount = instructions[instructionsIndex++];\n  let verticesCount = 0;\n  const holes = new Array(ringsCount - 1);\n  for (let i = 0; i < ringsCount; i++) {\n    verticesCount += instructions[instructionsIndex++];\n    if (i < ringsCount - 1) {\n      holes[i] = verticesCount;\n    }\n  }\n  const flatCoords = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + verticesCount * instructionsPerVertex\n  );\n\n  // pushing to vertices and indices!! this is where the magic happens\n  const result = earcut(flatCoords, holes, instructionsPerVertex);\n  for (let i = 0; i < result.length; i++) {\n    indexArray.push(result[i] + vertexArray.length / attributesPerVertex);\n  }\n  for (let i = 0; i < flatCoords.length; i += 2) {\n    vertexArray.push(flatCoords[i], flatCoords[i + 1], ...customAttributes);\n  }\n\n  return instructionsIndex + verticesCount * instructionsPerVertex;\n}\n\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n  const canvas = document.createElement('canvas');\n  const image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, array) {\n  array = array || [];\n  const radix = 256;\n  const divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n  array[2] = (Math.floor(id / radix) % radix) / divide;\n  array[3] = (id % radix) / divide;\n  return array;\n}\n\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n  let id = 0;\n  const radix = 256;\n  const mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}