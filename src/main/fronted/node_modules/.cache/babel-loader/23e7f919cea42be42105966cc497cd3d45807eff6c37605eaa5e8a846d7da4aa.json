{"ast":null,"code":"import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n  get status() {\n    return this.response.statusCode;\n  }\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = this.parsedUrl.protocol === 'http:' ? http : https;\n  }\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get({\n        ...this.parsedUrl,\n        headers\n      }, response => {\n        const dataPromise = new Promise(resolveData => {\n          const chunks = [];\n\n          // collect chunks\n          response.on('data', chunk => {\n            chunks.push(chunk);\n          });\n\n          // concatenate all chunks and resolve the promise with the resulting buffer\n          response.on('end', () => {\n            const data = Buffer.concat(chunks).buffer;\n            resolveData(data);\n          });\n          response.on('error', reject);\n        });\n        resolve(new HttpResponse(response, dataPromise));\n      });\n      request.on('error', reject);\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n  async request({\n    headers,\n    signal\n  } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}","map":{"version":3,"names":["http","https","urlMod","BaseClient","BaseResponse","AbortError","HttpResponse","constructor","response","dataPromise","status","statusCode","getHeader","name","headers","getData","data","HttpClient","url","parsedUrl","parse","httpApi","protocol","constructRequest","signal","Promise","resolve","reject","request","get","resolveData","chunks","on","chunk","push","Buffer","concat","buffer","aborted","destroy","addEventListener"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/geotiff/dist-module/source/client/http.js"],"sourcesContent":["import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}