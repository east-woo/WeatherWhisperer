{"ast":null,"code":"/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals.js';\nimport { assign, endsWith, forEach, invert, times } from './utils.js';\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return buff[p] << 8 | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map(i => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, i => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, i => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = n >> 8 & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = n >> 24 & 255;\n    buff[p + 1] = n >> 16 & 255;\n    buff[p + 2] = n >> 8 & 255;\n    buff[p + 3] = n >> 0 & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, i => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8)\n};\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, i => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n  const keys = Object.keys(ifd).filter(key => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n  let eoff = offset + 12 * keys.length + 4;\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n    let val = ifd[key];\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n    const num = val.length;\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n    bin.writeUint(data, offset, num);\n    offset += 4;\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, i => {\n        bin.writeUshort(data, toff + 2 * i, val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, i => {\n        bin.writeUint(data, toff + 4 * i, val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, i => {\n        bin.writeUint(data, toff + 8 * i, Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + 8 * i + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, i => {\n        bin.writeDouble(data, toff + 8 * i, val[i]);\n      });\n    }\n    if (dlen > 4) {\n      dlen += dlen & 1;\n      eoff += dlen;\n    }\n    offset += 4;\n  }\n  return [offset, eoff];\n};\nconst encodeIfds = ifds => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n  let ifdo = 8;\n  bin.writeUint(data, offset, ifdo);\n  offset += 4;\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n  const ifd = {\n    256: [width],\n    // ImageWidth\n    257: [height],\n    // ImageLength\n    273: [numBytesInIfd],\n    // strips offset\n    278: [height],\n    // RowsPerStrip\n    305: 'geotiff.js' // no array for ASCII(Z)\n  };\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n  const img = new Uint8Array(values);\n  const samplesPerPixel = ifd[277];\n  const data = new Uint8Array(numBytesInIfd + width * height * samplesPerPixel);\n  times(prfx.length, i => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n  return data.buffer;\n};\nconst convertToTids = input => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\nconst toArray = input => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\nconst metadataDefaults = [['Compression', 1],\n// no compression\n['PlanarConfiguration', 1], ['ExtraSamples', 0]];\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, rowIndex => {\n      times(width, columnIndex => {\n        times(numBands, bandIndex => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n  metadataDefaults.forEach(tag => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n  const geoKeys = Object.keys(metadata).filter(key => endsWith(key, 'GeoKey')).sort((a, b) => name2code[a] - name2code[b]);\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach(name => {\n      const code = Number(name2code[name]);\n      const tagType = fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach(geoKey => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey of geoKeys) {\n    if (metadata.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n  ['Compression', 'ExtraSamples', 'GeographicTypeGeoKey', 'GTModelTypeGeoKey', 'GTRasterTypeGeoKey', 'ImageLength',\n  // synonym of ImageHeight\n  'ImageWidth', 'Orientation', 'PhotometricInterpretation', 'ProjectedCSTypeGeoKey', 'PlanarConfiguration', 'ResolutionUnit', 'SamplesPerPixel', 'XPosition', 'YPosition', 'RowsPerStrip'].forEach(name => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n  const encodedMetadata = convertToTids(metadata);\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n  return outputImage;\n}","map":{"version":3,"names":["fieldTagNames","fieldTagTypes","fieldTypeNames","geoKeyNames","assign","endsWith","forEach","invert","times","tagName2Code","geoKeyName2Code","name2code","typeName2byte","numBytesInIfd","_binBE","nextZero","data","o","oincr","readUshort","buff","p","readShort","a","ui8","i16","readInt","i32","readUint","ui32","readASCII","l","map","i","String","fromCharCode","join","readFloat","fl32","readDouble","fl64","writeUshort","n","writeUint","writeASCII","s","length","charCodeAt","Uint8Array","Float64Array","buffer","writeDouble","_writeIFD","bin","_offset","ifd","offset","keys","Object","filter","key","undefined","eoff","tag","parseInt","typeName","typeNum","Error","val","num","dlen","toff","Math","round","encodeIfds","ifds","ifdo","noffs","slice","result","encodeImage","values","width","height","metadata","hasOwnProperty","prfx","img","samplesPerPixel","value","convertToTids","input","console","error","toArray","Array","isArray","metadataDefaults","writeGeotiff","isFlattened","numBands","flattenedValues","ImageLength","ImageWidth","rowIndex","columnIndex","bandIndex","push","BitsPerSample","PhotometricInterpretation","SamplesPerPixel","StripByteCounts","ModelPixelScale","SampleFormat","GeographicTypeGeoKey","ModelTiepoint","GeogCitationGeoKey","GTModelTypeGeoKey","geoKeys","sort","b","GeoAsciiParams","geoAsciiParams","name","code","Number","tagType","toString","GeoKeyDirectory","NumberOfKeys","geoKey","KeyID","Count","TIFFTagLocation","valueOffset","log","encodedMetadata","outputImage"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/geotiff/dist-module/geotiffwriter.js"],"sourcesContent":["/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals.js';\nimport { assign, endsWith, forEach, invert, times } from './utils.js';\n\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  times(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, (rowIndex) => {\n      times(width, (columnIndex) => {\n        times(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => endsWith(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey of geoKeys) {\n    if (metadata.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n    'RowsPerStrip',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}