{"ast":null,"code":"/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.SBYTE:\n    case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT:\n    case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG:\n    case fieldTypes.SLONG:\n    case fieldTypes.FLOAT:\n    case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL:\n    case fieldTypes.SRATIONAL:\n    case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8:\n    case fieldTypes.SLONG8:\n    case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = rawGeoKeyDirectory[i + 1] ? fieldTagNames[rawGeoKeyDirectory[i + 1]] : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count);\n      readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count);\n      readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count);\n      readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count);\n      readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG:\n    case fieldTypes.IFD:\n      values = new Uint32Array(count);\n      readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count);\n      readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8:\n    case fieldTypes.IFD8:\n      values = new Array(count);\n      readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count);\n      readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2);\n      readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2);\n      readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count);\n      readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count);\n      readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);\n    }\n  } else {\n    // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);\n      values[i + 1] = readMethod.call(dataSlice, offset + (i * fieldTypeLength + 4));\n    }\n  }\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const {\n      window: imageWindow,\n      width,\n      height\n    } = options;\n    let {\n      resX,\n      resY,\n      bbox\n    } = options;\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n        bbox = [oX + imageWindow[0] * rX, oY + imageWindow[1] * rY, oX + imageWindow[2] * rX, oY + imageWindow[3] * rY];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const {\n          SubfileType: subfileType,\n          NewSubfileType: newSubfileType\n        } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n        usedImage = image;\n        if (resX && resX > imgResX || resY && resY > imgResY) {\n          break;\n        }\n      }\n    }\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n      wnd = [Math.round((bbox[0] - oX) / imageResX), Math.round((bbox[1] - oY) / imageResY), Math.round((bbox[2] - oX) / imageResX), Math.round((bbox[3] - oY) / imageResY)];\n      wnd = [Math.min(wnd[0], wnd[2]), Math.min(wnd[1], wnd[3]), Math.max(wnd[0], wnd[2]), Math.max(wnd[1], wnd[3])];\n    }\n    return usedImage.readRasters({\n      ...options,\n      window: wnd\n    });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice((await this.source.fetch([{\n      offset,\n      length: typeof size !== 'undefined' ? size : fallbackSize\n    }]))[0], offset, this.littleEndian, this.bigTiff);\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff ? dataSlice.readUint64(offset) : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = numDirEntries * entrySize + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff ? dataSlice.readUint64(i + 4) : dataSlice.readUint32(i + 4);\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1 && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(offset + offsetSize + entrySize * numDirEntries);\n    return new ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset);\n  }\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(ifd.fileDirectory, ifd.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source);\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString.split('\\n').filter(line => line.length > 0).map(line => line.split('=')).forEach(([key, value]) => {\n        this.ghostValues[key] = value;\n      });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{\n      offset: 0,\n      length: 1024\n    }], signal))[0];\n    const dataView = new DataView64(headerData);\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n    const firstIFDOffset = bigTiff ? dataView.getUint64(8, littleEndian) : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map(file => file.parseFileDirectoryAt(file.firstIFDOffset)));\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(ifd.fileDirectory, ifd.geoKeyDirectory, imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source);\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()].concat(this.overviewFiles.map(file => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(makeCustomSource(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(overviewUrls.map(url => GeoTIFF.fromSource(makeRemoteSource(url, options))));\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };","map":{"version":3,"names":["GeoTIFFImage","DataView64","DataSlice","Pool","makeRemoteSource","makeCustomSource","makeBufferSource","makeFileReaderSource","makeFileSource","BaseClient","BaseResponse","fieldTypes","fieldTagNames","arrayFields","geoKeyNames","writeGeotiff","globals","rgb","getDecoder","addDecoder","setLogger","default","BaseDecoder","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","RangeError","parseGeoKeyDirectory","fileDirectory","rawGeoKeyDirectory","GeoKeyDirectory","geoKeyDirectory","i","key","location","count","offset","value","Error","substring","subarray","getValues","dataSlice","values","readMethod","fieldTypeLength","Uint8Array","readUint8","Int8Array","readInt8","Uint16Array","readUint16","Int16Array","readInt16","Uint32Array","readUint32","Int32Array","readInt32","Array","readUint64","readInt64","Float32Array","readFloat32","Float64Array","readFloat64","call","TextDecoder","decode","ImageFileDirectory","constructor","nextIFDByteOffset","GeoTIFFImageIndexError","index","GeoTIFFBase","readRasters","options","window","imageWindow","width","height","resX","resY","bbox","firstImage","getImage","usedImage","imageCount","getImageCount","imgBBox","getBoundingBox","oX","oY","getOrigin","rX","rY","getResolution","usedBBox","allImages","image","SubfileType","subfileType","NewSubfileType","newSubfileType","push","sort","a","b","getWidth","length","imgResX","imgResY","getHeight","wnd","imageResX","imageResY","Math","round","min","max","GeoTIFF","source","littleEndian","bigTiff","firstIFDOffset","cache","ifdRequests","ghostValues","getSlice","size","fallbackSize","fetch","parseFileDirectoryAt","entrySize","offsetSize","numDirEntries","byteSize","covers","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","readOffset","fieldDataSlice","indexOf","requestIFD","e","previousIfd","ifd","dataView","hasNext","getGhostValues","detectionString","heuristicAreaSize","slice","valuesString","firstLine","split","metadataSize","Number","fullString","filter","line","map","forEach","fromSource","signal","headerData","BOM","getUint16","TypeError","magicNumber","offsetByteSize","getUint64","getUint32","close","MultiGeoTIFF","mainFile","overviewFiles","imageFiles","concat","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","parseFileDirectoriesPerFile","requests","file","Promise","all","visited","relativeIndex","imageFile","ii","imageCounts","reduce","ifds","fromUrl","url","fromCustomClient","client","fromArrayBuffer","arrayBuffer","fromFile","path","fromBlob","blob","fromUrls","mainUrl","overviewUrls","writeArrayBuffer","metadata"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/geotiff/dist-module/geotiff.js"],"sourcesContent":["/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(makeCustomSource(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}