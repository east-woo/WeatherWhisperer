{"ast":null,"code":"/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n  let x2 = flatCoordinates[offset];\n  let y2 = flatCoordinates[offset + 1];\n  let x1 = 0;\n  let y1 = 0;\n  let segmentLength = 0;\n  let segmentM = 0;\n  function advance() {\n    x1 = x2;\n    y1 = y2;\n    offset += stride;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    segmentM += segmentLength;\n    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n  do {\n    advance();\n  } while (offset < end - stride && segmentM + segmentLength < startM);\n  let interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n  const beginX = lerp(x1, x2, interpolate);\n  const beginY = lerp(y1, y2, interpolate);\n  const startOffset = offset - stride;\n  const startLength = segmentM;\n  const endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n  while (offset < end - stride && segmentM + segmentLength < endM) {\n    advance();\n  }\n  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n  const endX = lerp(x1, x2, interpolate);\n  const endY = lerp(y1, y2, interpolate);\n\n  // Keep text upright\n  let reverse;\n  if (rotation) {\n    const flat = [beginX, beginY, endX, endY];\n    rotate(flat, 0, 4, 2, rotation, flat, flat);\n    reverse = flat[0] > flat[2];\n  } else {\n    reverse = beginX > endX;\n  }\n  const PI = Math.PI;\n  const result = [];\n  const singleSegment = startOffset + stride === offset;\n  offset = startOffset;\n  segmentLength = 0;\n  segmentM = startLength;\n  x2 = flatCoordinates[offset];\n  y2 = flatCoordinates[offset + 1];\n  let previousAngle;\n  // All on the same segment\n  if (singleSegment) {\n    advance();\n    previousAngle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      previousAngle += previousAngle > 0 ? -PI : PI;\n    }\n    const x = (endX + beginX) / 2;\n    const y = (endY + beginY) / 2;\n    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n    return result;\n  }\n\n  // rendering across line segments\n  text = text.replace(/\\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines\n\n  for (let i = 0, ii = text.length; i < ii;) {\n    advance();\n    let angle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      angle += angle > 0 ? -PI : PI;\n    }\n    if (previousAngle !== undefined) {\n      let delta = angle - previousAngle;\n      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    previousAngle = angle;\n    const iStart = i;\n    let charLength = 0;\n    for (; i < ii; ++i) {\n      const index = reverse ? ii - i - 1 : i;\n      const len = scale * measureAndCacheTextWidth(font, text[index], cache);\n      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {\n        break;\n      }\n      charLength += len;\n    }\n    if (i === iStart) {\n      continue;\n    }\n    const chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);\n    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;\n    const x = lerp(x1, x2, interpolate);\n    const y = lerp(y1, y2, interpolate);\n    result.push([x, y, charLength / 2, angle, chars]);\n    startM += charLength;\n  }\n  return result;\n}","map":{"version":3,"names":["lerp","rotate","drawTextOnPath","flatCoordinates","offset","end","stride","text","startM","maxAngle","scale","measureAndCacheTextWidth","font","cache","rotation","x2","y2","x1","y1","segmentLength","segmentM","advance","Math","sqrt","interpolate","beginX","beginY","startOffset","startLength","endM","endX","endY","reverse","flat","PI","result","singleSegment","previousAngle","atan2","x","y","replace","i","ii","length","angle","undefined","delta","abs","iStart","charLength","index","len","chars","substring","push"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/geom/flat/textpath.js"],"sourcesContent":["/**\n * @module ol/geom/flat/textpath\n */\nimport {lerp} from '../../math.js';\nimport {rotate} from './transform.js';\n\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  text,\n  startM,\n  maxAngle,\n  scale,\n  measureAndCacheTextWidth,\n  font,\n  cache,\n  rotation\n) {\n  let x2 = flatCoordinates[offset];\n  let y2 = flatCoordinates[offset + 1];\n  let x1 = 0;\n  let y1 = 0;\n  let segmentLength = 0;\n  let segmentM = 0;\n\n  function advance() {\n    x1 = x2;\n    y1 = y2;\n    offset += stride;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    segmentM += segmentLength;\n    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n  do {\n    advance();\n  } while (offset < end - stride && segmentM + segmentLength < startM);\n\n  let interpolate =\n    segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n  const beginX = lerp(x1, x2, interpolate);\n  const beginY = lerp(y1, y2, interpolate);\n\n  const startOffset = offset - stride;\n  const startLength = segmentM;\n  const endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n  while (offset < end - stride && segmentM + segmentLength < endM) {\n    advance();\n  }\n  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n  const endX = lerp(x1, x2, interpolate);\n  const endY = lerp(y1, y2, interpolate);\n\n  // Keep text upright\n  let reverse;\n  if (rotation) {\n    const flat = [beginX, beginY, endX, endY];\n    rotate(flat, 0, 4, 2, rotation, flat, flat);\n    reverse = flat[0] > flat[2];\n  } else {\n    reverse = beginX > endX;\n  }\n\n  const PI = Math.PI;\n  const result = [];\n  const singleSegment = startOffset + stride === offset;\n\n  offset = startOffset;\n  segmentLength = 0;\n  segmentM = startLength;\n  x2 = flatCoordinates[offset];\n  y2 = flatCoordinates[offset + 1];\n\n  let previousAngle;\n  // All on the same segment\n  if (singleSegment) {\n    advance();\n\n    previousAngle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      previousAngle += previousAngle > 0 ? -PI : PI;\n    }\n    const x = (endX + beginX) / 2;\n    const y = (endY + beginY) / 2;\n    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n    return result;\n  }\n\n  // rendering across line segments\n  text = text.replace(/\\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines\n\n  for (let i = 0, ii = text.length; i < ii; ) {\n    advance();\n    let angle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      angle += angle > 0 ? -PI : PI;\n    }\n    if (previousAngle !== undefined) {\n      let delta = angle - previousAngle;\n      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    previousAngle = angle;\n\n    const iStart = i;\n    let charLength = 0;\n    for (; i < ii; ++i) {\n      const index = reverse ? ii - i - 1 : i;\n      const len = scale * measureAndCacheTextWidth(font, text[index], cache);\n      if (\n        offset + stride < end &&\n        segmentM + segmentLength < startM + charLength + len / 2\n      ) {\n        break;\n      }\n      charLength += len;\n    }\n    if (i === iStart) {\n      continue;\n    }\n    const chars = reverse\n      ? text.substring(ii - iStart, ii - i)\n      : text.substring(iStart, i);\n    interpolate =\n      segmentLength === 0\n        ? 0\n        : (startM + charLength / 2 - segmentM) / segmentLength;\n    const x = lerp(x1, x2, interpolate);\n    const y = lerp(y1, y2, interpolate);\n    result.push([x, y, charLength / 2, angle, chars]);\n    startM += charLength;\n  }\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}