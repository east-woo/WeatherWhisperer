{"ast":null,"code":"/**\n * @module ol/renderer/canvas/VectorImageLayer\n */\nimport CanvasImageLayerRenderer from './ImageLayer.js';\nimport CanvasVectorLayerRenderer from './VectorLayer.js';\nimport EventType from '../../events/EventType.js';\nimport ImageCanvas from '../../ImageCanvas.js';\nimport ImageState from '../../ImageState.js';\nimport RBush from 'rbush';\nimport ViewHint from '../../ViewHint.js';\nimport { apply, compose, create } from '../../transform.js';\nimport { fromResolutionLike } from '../../resolution.js';\nimport { getHeight, getWidth, isEmpty, scaleFromCenter } from '../../extent.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasVectorImageLayerRenderer extends CanvasImageLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorImage.js\").default} layer Vector image layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @private\n     * @type {import(\"./VectorLayer.js\").default}\n     */\n    this.vectorRenderer_ = new CanvasVectorLayerRenderer(layer);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.layerImageRatio_ = layer.getImageRatio();\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.coordinateToVectorPixelTransform_ = create();\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.vectorRenderer_.dispose();\n    super.disposeInternal();\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    if (!this.vectorRenderer_) {\n      return Promise.resolve([]);\n    }\n    const vectorPixel = apply(this.coordinateToVectorPixelTransform_, apply(this.renderedPixelToCoordinateTransform_, pixel.slice()));\n    return this.vectorRenderer_.getFeatures(vectorPixel);\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    this.vectorRenderer_.handleFontsChanged();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n    const hints = frameState.viewHints;\n    const vectorRenderer = this.vectorRenderer_;\n    let renderedExtent = frameState.extent;\n    if (this.layerImageRatio_ !== 1) {\n      renderedExtent = renderedExtent.slice(0);\n      scaleFromCenter(renderedExtent, this.layerImageRatio_);\n    }\n    const width = getWidth(renderedExtent) / viewResolution;\n    const height = getHeight(renderedExtent) / viewResolution;\n    if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !isEmpty(renderedExtent)) {\n      vectorRenderer.useContainer(null, null);\n      const context = vectorRenderer.context;\n      const layerState = frameState.layerStatesArray[frameState.layerIndex];\n      const imageLayerState = Object.assign({}, layerState, {\n        opacity: 1\n      });\n      const imageFrameState = /** @type {import(\"../../Map.js\").FrameState} */\n      Object.assign({}, frameState, {\n        declutterTree: new RBush(9),\n        extent: renderedExtent,\n        size: [width, height],\n        viewState: ( /** @type {import(\"../../View.js\").State} */\n        Object.assign({}, frameState.viewState, {\n          rotation: 0\n        })),\n        layerStatesArray: [imageLayerState],\n        layerIndex: 0\n      });\n      let emptyImage = true;\n      const image = new ImageCanvas(renderedExtent, viewResolution, pixelRatio, context.canvas, function (callback) {\n        if (vectorRenderer.prepareFrame(imageFrameState) && vectorRenderer.replayGroupChanged) {\n          vectorRenderer.clipping = false;\n          if (vectorRenderer.renderFrame(imageFrameState, null)) {\n            vectorRenderer.renderDeclutter(imageFrameState);\n            emptyImage = false;\n          }\n          callback();\n        }\n      });\n      image.addEventListener(EventType.CHANGE, () => {\n        if (image.getState() !== ImageState.LOADED) {\n          return;\n        }\n        this.image_ = emptyImage ? null : image;\n        const imagePixelRatio = image.getPixelRatio();\n        const renderedResolution = fromResolutionLike(image.getResolution()) * pixelRatio / imagePixelRatio;\n        this.renderedResolution = renderedResolution;\n        this.coordinateToVectorPixelTransform_ = compose(this.coordinateToVectorPixelTransform_, width / 2, height / 2, 1 / renderedResolution, -1 / renderedResolution, 0, -viewState.center[0], -viewState.center[1]);\n      });\n      image.load();\n    }\n    if (this.image_) {\n      this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();\n    }\n    return !!this.image_;\n  }\n\n  /**\n   */\n  preRender() {}\n\n  /**\n   */\n  postRender() {}\n\n  /**\n   */\n  renderDeclutter() {}\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n    if (this.vectorRenderer_) {\n      return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches);\n    }\n    return super.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches);\n  }\n}\nexport default CanvasVectorImageLayerRenderer;","map":{"version":3,"names":["CanvasImageLayerRenderer","CanvasVectorLayerRenderer","EventType","ImageCanvas","ImageState","RBush","ViewHint","apply","compose","create","fromResolutionLike","getHeight","getWidth","isEmpty","scaleFromCenter","CanvasVectorImageLayerRenderer","constructor","layer","vectorRenderer_","layerImageRatio_","getImageRatio","coordinateToVectorPixelTransform_","renderedPixelToCoordinateTransform_","disposeInternal","dispose","getFeatures","pixel","Promise","resolve","vectorPixel","slice","handleFontsChanged","prepareFrame","frameState","pixelRatio","viewState","viewResolution","resolution","hints","viewHints","vectorRenderer","renderedExtent","extent","width","height","ANIMATING","INTERACTING","useContainer","context","layerState","layerStatesArray","layerIndex","imageLayerState","Object","assign","opacity","imageFrameState","declutterTree","size","rotation","emptyImage","image","canvas","callback","replayGroupChanged","clipping","renderFrame","renderDeclutter","addEventListener","CHANGE","getState","LOADED","image_","imagePixelRatio","getPixelRatio","renderedResolution","getResolution","center","load","pixelToCoordinateTransform","preRender","postRender","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/renderer/canvas/VectorImageLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/VectorImageLayer\n */\nimport CanvasImageLayerRenderer from './ImageLayer.js';\nimport CanvasVectorLayerRenderer from './VectorLayer.js';\nimport EventType from '../../events/EventType.js';\nimport ImageCanvas from '../../ImageCanvas.js';\nimport ImageState from '../../ImageState.js';\nimport RBush from 'rbush';\nimport ViewHint from '../../ViewHint.js';\nimport {apply, compose, create} from '../../transform.js';\nimport {fromResolutionLike} from '../../resolution.js';\nimport {getHeight, getWidth, isEmpty, scaleFromCenter} from '../../extent.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasVectorImageLayerRenderer extends CanvasImageLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorImage.js\").default} layer Vector image layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @private\n     * @type {import(\"./VectorLayer.js\").default}\n     */\n    this.vectorRenderer_ = new CanvasVectorLayerRenderer(layer);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.layerImageRatio_ = layer.getImageRatio();\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.coordinateToVectorPixelTransform_ = create();\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.vectorRenderer_.dispose();\n    super.disposeInternal();\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    if (!this.vectorRenderer_) {\n      return Promise.resolve([]);\n    }\n    const vectorPixel = apply(\n      this.coordinateToVectorPixelTransform_,\n      apply(this.renderedPixelToCoordinateTransform_, pixel.slice())\n    );\n    return this.vectorRenderer_.getFeatures(vectorPixel);\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    this.vectorRenderer_.handleFontsChanged();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const hints = frameState.viewHints;\n    const vectorRenderer = this.vectorRenderer_;\n    let renderedExtent = frameState.extent;\n    if (this.layerImageRatio_ !== 1) {\n      renderedExtent = renderedExtent.slice(0);\n      scaleFromCenter(renderedExtent, this.layerImageRatio_);\n    }\n    const width = getWidth(renderedExtent) / viewResolution;\n    const height = getHeight(renderedExtent) / viewResolution;\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      vectorRenderer.useContainer(null, null);\n      const context = vectorRenderer.context;\n      const layerState = frameState.layerStatesArray[frameState.layerIndex];\n      const imageLayerState = Object.assign({}, layerState, {opacity: 1});\n      const imageFrameState = /** @type {import(\"../../Map.js\").FrameState} */ (\n        Object.assign({}, frameState, {\n          declutterTree: new RBush(9),\n          extent: renderedExtent,\n          size: [width, height],\n          viewState: /** @type {import(\"../../View.js\").State} */ (\n            Object.assign({}, frameState.viewState, {\n              rotation: 0,\n            })\n          ),\n          layerStatesArray: [imageLayerState],\n          layerIndex: 0,\n        })\n      );\n      let emptyImage = true;\n      const image = new ImageCanvas(\n        renderedExtent,\n        viewResolution,\n        pixelRatio,\n        context.canvas,\n        function (callback) {\n          if (\n            vectorRenderer.prepareFrame(imageFrameState) &&\n            vectorRenderer.replayGroupChanged\n          ) {\n            vectorRenderer.clipping = false;\n            if (vectorRenderer.renderFrame(imageFrameState, null)) {\n              vectorRenderer.renderDeclutter(imageFrameState);\n              emptyImage = false;\n            }\n            callback();\n          }\n        }\n      );\n\n      image.addEventListener(EventType.CHANGE, () => {\n        if (image.getState() !== ImageState.LOADED) {\n          return;\n        }\n        this.image_ = emptyImage ? null : image;\n        const imagePixelRatio = image.getPixelRatio();\n        const renderedResolution =\n          (fromResolutionLike(image.getResolution()) * pixelRatio) /\n          imagePixelRatio;\n        this.renderedResolution = renderedResolution;\n        this.coordinateToVectorPixelTransform_ = compose(\n          this.coordinateToVectorPixelTransform_,\n          width / 2,\n          height / 2,\n          1 / renderedResolution,\n          -1 / renderedResolution,\n          0,\n          -viewState.center[0],\n          -viewState.center[1]\n        );\n      });\n      image.load();\n    }\n\n    if (this.image_) {\n      this.renderedPixelToCoordinateTransform_ =\n        frameState.pixelToCoordinateTransform.slice();\n    }\n\n    return !!this.image_;\n  }\n\n  /**\n   */\n  preRender() {}\n\n  /**\n   */\n  postRender() {}\n\n  /**\n   */\n  renderDeclutter() {}\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    if (this.vectorRenderer_) {\n      return this.vectorRenderer_.forEachFeatureAtCoordinate(\n        coordinate,\n        frameState,\n        hitTolerance,\n        callback,\n        matches\n      );\n    }\n    return super.forEachFeatureAtCoordinate(\n      coordinate,\n      frameState,\n      hitTolerance,\n      callback,\n      matches\n    );\n  }\n}\n\nexport default CanvasVectorImageLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}