{"ast":null,"code":"import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, {\n    blockSize = 65536,\n    cacheSize = 100\n  } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n    this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      }\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n    this.abortedBlockIds = new Set();\n  }\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n    for (const {\n      offset,\n      length\n    } of slices) {\n      let top = offset + length;\n      const {\n        fileSize\n      } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds.filter(id => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach(id => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n    const blocks = allBlockIds.map(id => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter(i => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(blockOffset, data.byteLength, data, blockId);\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n    groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map(slice => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n      return sliceData;\n    });\n  }\n}","map":{"version":3,"names":["QuickLRU","BaseSource","AbortError","AggregateError","wait","zip","Block","constructor","offset","length","data","top","BlockGroup","blockIds","BlockedSource","source","blockSize","cacheSize","blockCache","maxSize","onEviction","blockId","block","evictedBlocks","set","Map","blockRequests","blockIdsToFetch","Set","abortedBlockIds","fileSize","fetch","slices","signal","missingBlockIds","allBlockIds","clear","Math","min","firstBlockOffset","floor","current","has","add","push","get","fetchBlocks","missingRequests","Promise","allSettled","abortedBlockRequests","filter","id","forEach","aborted","Error","blocks","map","failedBlocks","i","requiredBlocks","readSliceData","size","groups","groupBlocks","groupRequests","groupIndex","group","response","blockOffset","o","t","byteLength","slice","delete","err","name","sortedBlockIds","Array","from","sort","a","b","lastBlockId","blockIdLow","blockIdHigh","sliceData","ArrayBuffer","sliceView","Uint8Array","delta","topDelta","blockInnerOffset","rangeInnerOffset","usedBlockLength","blockView"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/geotiff/dist-module/source/blockedsource.js"],"sourcesContent":["import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}