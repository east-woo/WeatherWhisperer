{"ast":null,"code":"/**\n * Class for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\nimport { LINESTRING_ANGLE_COSINE_CUTOFF } from '../render/webgl/utils.js';\nimport { colorToGlsl, numberToGlsl, stringToGlsl } from '../expr/gpu.js';\nimport { createDefaultStyle } from '../style/flat.js';\nexport const COMMON_HEADER = \"#ifdef GL_FRAGMENT_PRECISION_HIGH\\nprecision highp float;\\n#else\\nprecision mediump float;\\n#endif\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_screenToWorldMatrix;\\nuniform vec2 u_viewportSizePx;\\nuniform float u_pixelRatio;\\nuniform float u_globalAlpha;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\nuniform float u_rotation;\\nuniform vec4 u_renderExtent;\\nuniform vec2 u_patternOrigin;\\nuniform float u_depth;\\nuniform mediump int u_hitDetection;\\n\\nconst float PI = 3.141592653589793238;\\nconst float TWO_PI = 2.0 * PI;\\n\\n// this used to produce an alpha-premultiplied color from a texture\\nvec4 samplePremultiplied(sampler2D sampler, vec2 texCoord) {\\n  vec4 color = texture2D(sampler, texCoord);\\n  return vec4(color.rgb * color.a, color.a);\\n}\\n\";\nconst DEFAULT_STYLE = createDefaultStyle();\n\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSymbolSizeExpression('...')\n *   .getSymbolFragmentShader();\n * ```\n */\nexport class ShaderBuilder {\n  constructor() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms_ = [];\n\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.attributes_ = [];\n\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n    this.varyings_ = [];\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasSymbol_ = false;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolSizeExpression_ = \"vec2(\".concat(numberToGlsl(DEFAULT_STYLE['circle-radius']), \" + \").concat(numberToGlsl(DEFAULT_STYLE['circle-stroke-width'] * 0.5), \")\");\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolRotationExpression_ = '0.0';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolOffsetExpression_ = 'vec2(0.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolColorExpression_ = colorToGlsl( /** @type {string} */DEFAULT_STYLE['circle-fill-color']);\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.texCoordExpression_ = 'vec4(0.0, 0.0, 1.0, 1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.discardExpression_ = 'false';\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.symbolRotateWithView_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasStroke_ = false;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.strokeWidthExpression_ = numberToGlsl(DEFAULT_STYLE['stroke-width']);\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.strokeColorExpression_ = colorToGlsl( /** @type {string} */DEFAULT_STYLE['stroke-color']);\n\n    /**\n     * @private\n     */\n    this.strokeOffsetExpression_ = '0.';\n\n    /**\n     * @private\n     */\n    this.strokeCapExpression_ = stringToGlsl('round');\n\n    /**\n     * @private\n     */\n    this.strokeJoinExpression_ = stringToGlsl('round');\n\n    /**\n     * @private\n     */\n    this.strokeMiterLimitExpression_ = '10.';\n\n    /**\n     * @private\n     */\n    this.strokeDistanceFieldExpression_ = '-1000.';\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasFill_ = false;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.fillColorExpression_ = colorToGlsl( /** @type {string} */DEFAULT_STYLE['fill-color']);\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.vertexShaderFunctions_ = [];\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.fragmentShaderFunctions_ = [];\n  }\n\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n  addUniform(name) {\n    this.uniforms_.push(name);\n    return this;\n  }\n\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n  addAttribute(name) {\n    this.attributes_.push(name);\n    return this;\n  }\n\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n  addVarying(name, type, expression) {\n    this.varyings_.push({\n      name: name,\n      type: type,\n      expression: expression\n    });\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolSizeExpression(expression) {\n    this.hasSymbol_ = true;\n    this.symbolSizeExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current symbol size expression\n   */\n  getSymbolSizeExpression() {\n    return this.symbolSizeExpression_;\n  }\n\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolRotationExpression(expression) {\n    this.symbolRotationExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolOffsetExpression(expression) {\n    this.symbolOffsetExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current symbol offset expression\n   */\n  getSymbolOffsetExpression() {\n    return this.symbolOffsetExpression_;\n  }\n\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolColorExpression(expression) {\n    this.hasSymbol_ = true;\n    this.symbolColorExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current symbol color expression\n   */\n  getSymbolColorExpression() {\n    return this.symbolColorExpression_;\n  }\n\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setTextureCoordinateExpression(expression) {\n    this.texCoordExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setFragmentDiscardExpression(expression) {\n    this.discardExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current fragment discard expression\n   */\n  getFragmentDiscardExpression() {\n    return this.discardExpression_;\n  }\n\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolRotateWithView(rotateWithView) {\n    this.symbolRotateWithView_ = rotateWithView;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke width expression, returning value in pixels\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeWidthExpression(expression) {\n    this.hasStroke_ = true;\n    this.strokeWidthExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke color expression, evaluate to `vec4`: can rely on currentLengthPx and currentRadiusPx\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeColorExpression(expression) {\n    this.hasStroke_ = true;\n    this.strokeColorExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current stroke color expression\n   */\n  getStrokeColorExpression() {\n    return this.strokeColorExpression_;\n  }\n\n  /**\n   * @param {string} expression Stroke color expression, evaluate to `float`\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeOffsetExpression(expression) {\n    this.strokeOffsetExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke line cap expression, evaluate to `float`\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeCapExpression(expression) {\n    this.strokeCapExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke line join expression, evaluate to `float`\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeJoinExpression(expression) {\n    this.strokeJoinExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke miter limit expression, evaluate to `float`\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeMiterLimitExpression(expression) {\n    this.strokeMiterLimitExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke distance field expression, evaluate to `float`\n   * This can override the default distance field; can rely on currentLengthPx and currentRadiusPx\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeDistanceFieldExpression(expression) {\n    this.strokeDistanceFieldExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Fill color expression, evaluate to `vec4`\n   * @return {ShaderBuilder} the builder object\n   */\n  setFillColorExpression(expression) {\n    this.hasFill_ = true;\n    this.fillColorExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current fill color expression\n   */\n  getFillColorExpression() {\n    return this.fillColorExpression_;\n  }\n  addVertexShaderFunction(code) {\n    if (this.vertexShaderFunctions_.includes(code)) {\n      return;\n    }\n    this.vertexShaderFunctions_.push(code);\n  }\n  addFragmentShaderFunction(code) {\n    if (this.fragmentShaderFunctions_.includes(code)) {\n      return;\n    }\n    this.fragmentShaderFunctions_.push(code);\n  }\n\n  /**\n   * Generates a symbol vertex shader from the builder parameters\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getSymbolVertexShader() {\n    if (!this.hasSymbol_) {\n      return null;\n    }\n    return \"\".concat(COMMON_HEADER, \"\\n\").concat(this.uniforms_.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n'), \"\\nattribute vec2 a_position;\\nattribute float a_index;\\nattribute vec4 a_hitColor;\\n\").concat(this.attributes_.map(function (attribute) {\n      return 'attribute ' + attribute + ';';\n    }).join('\\n'), \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\nvarying vec4 v_hitColor;\\nvarying vec2 v_centerPx;\\nvarying float v_angle;\\nvarying vec2 v_quadSizePx;\\n\").concat(this.varyings_.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n'), \"\\n\").concat(this.vertexShaderFunctions_.join('\\n'), \"\\nvec2 pxToScreen(vec2 coordPx) {\\n  vec2 scaled = coordPx / u_viewportSizePx / 0.5;\\n  return scaled;\\n}\\n\\nvec2 screenToPx(vec2 coordScreen) {\\n  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;\\n}\\n\\nvoid main(void) {\\n  v_quadSizePx = \").concat(this.symbolSizeExpression_, \";\\n  vec2 halfSizePx = v_quadSizePx * 0.5;\\n  vec2 centerOffsetPx = \").concat(this.symbolOffsetExpression_, \";\\n  vec2 offsetPx = centerOffsetPx;\\n  if (a_index == 0.0) {\\n    offsetPx -= halfSizePx;\\n  } else if (a_index == 1.0) {\\n    offsetPx += halfSizePx * vec2(1., -1.);\\n  } else if (a_index == 2.0) {\\n    offsetPx += halfSizePx;\\n  } else {\\n    offsetPx += halfSizePx * vec2(-1., 1.);\\n  }\\n  float angle = \").concat(this.symbolRotationExpression_, \";\\n  \").concat(this.symbolRotateWithView_ ? 'angle += u_rotation;' : '', \"\\n  float c = cos(-angle);\\n  float s = sin(-angle);\\n  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);\\n  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\\n  gl_Position = center + vec4(pxToScreen(offsetPx), u_depth, 0.);\\n  vec4 texCoord = \").concat(this.texCoordExpression_, \";\\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\\n  v_texCoord = vec2(u, v);\\n  v_hitColor = a_hitColor;\\n  v_angle = angle;\\n  c = cos(-v_angle);\\n  s = sin(-v_angle);\\n  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y); \\n  v_centerPx = screenToPx(center.xy) + centerOffsetPx;\\n\").concat(this.varyings_.map(function (varying) {\n      return '  ' + varying.name + ' = ' + varying.expression + ';';\n    }).join('\\n'), \"\\n}\");\n  }\n\n  /**\n   * Generates a symbol fragment shader from the builder parameters\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getSymbolFragmentShader() {\n    if (!this.hasSymbol_) {\n      return null;\n    }\n    return \"\".concat(COMMON_HEADER, \"\\n\").concat(this.uniforms_.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n'), \"\\nvarying vec2 v_texCoord;\\nvarying vec4 v_hitColor;\\nvarying vec2 v_centerPx;\\nvarying float v_angle;\\nvarying vec2 v_quadSizePx;\\n\").concat(this.varyings_.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n'), \"\\n\").concat(this.fragmentShaderFunctions_.join('\\n'), \"\\n\\nvoid main(void) {\\n  if (\").concat(this.discardExpression_, \") { discard; }\\n  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center\\n  float c = cos(v_angle);\\n  float s = sin(v_angle);\\n  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);\\n  gl_FragColor = \").concat(this.symbolColorExpression_, \";\\n  if (u_hitDetection > 0) {\\n    if (gl_FragColor.a < 0.05) { discard; };\\n    gl_FragColor = v_hitColor;\\n  }\\n}\");\n  }\n\n  /**\n   * Generates a stroke vertex shader from the builder parameters\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getStrokeVertexShader() {\n    if (!this.hasStroke_) {\n      return null;\n    }\n    return \"\".concat(COMMON_HEADER, \"\\n\").concat(this.uniforms_.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n'), \"\\nattribute vec2 a_position;\\nattribute float a_index;\\nattribute vec2 a_segmentStart;\\nattribute vec2 a_segmentEnd;\\nattribute float a_parameters;\\nattribute float a_distance;\\nattribute vec2 a_joinAngles;\\nattribute vec4 a_hitColor;\\n\").concat(this.attributes_.map(function (attribute) {\n      return 'attribute ' + attribute + ';';\n    }).join('\\n'), \"\\nvarying vec2 v_segmentStart;\\nvarying vec2 v_segmentEnd;\\nvarying float v_angleStart;\\nvarying float v_angleEnd;\\nvarying float v_width;\\nvarying vec4 v_hitColor;\\nvarying float v_distanceOffsetPx;\\n\").concat(this.varyings_.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n'), \"\\n\").concat(this.vertexShaderFunctions_.join('\\n'), \"\\nvec2 worldToPx(vec2 worldPos) {\\n  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\\n  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;\\n}\\n\\nvec4 pxToScreen(vec2 pxPos) {\\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\\n  return vec4(screenPos, u_depth, 1.0);\\n}\\n\\nbool isCap(float joinAngle) {\\n  return joinAngle < -0.1;\\n}\\n\\nvec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {\\n  float halfAngle = joinAngle / 2.0;\\n  float c = cos(halfAngle);\\n  float s = sin(halfAngle);\\n  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);\\n  float length = 1.0 / s;\\n  return angleBisectorNormal * length;\\n}\\n\\nvec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {\\n  // if on a cap or the join angle is too high, offset the line along the segment normal\\n  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {\\n    return point - normal * offsetPx;\\n  }\\n  // offset is applied along the inverted normal (positive offset goes \\\"right\\\" relative to line direction)\\n  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;\\n}\\n\\nvoid main(void) {\\n  v_angleStart = a_joinAngles.x;\\n  v_angleEnd = a_joinAngles.y;\\n  float vertexNumber = floor(abs(a_parameters) / 10000. + 0.5);\\n  // we're reading the fractional part while keeping the sign (so -4.12 gives -0.12, 3.45 gives 0.45)\\n  float angleTangentSum = fract(abs(a_parameters) / 10000.) * 10000. * sign(a_parameters);\\n\\n  float lineWidth = \").concat(this.strokeWidthExpression_, \";\\n  float lineOffsetPx = \").concat(this.strokeOffsetExpression_, \";\\n\\n  // compute segment start/end in px with offset\\n  vec2 segmentStartPx = worldToPx(a_segmentStart);\\n  vec2 segmentEndPx = worldToPx(a_segmentEnd);\\n  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);\\n  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);\\n  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),\\n  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);\\n  \\n  // compute current vertex position\\n  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;\\n  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;\\n  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;\\n  vec2 joinDirection;\\n  vec2 positionPx = vertexNumber < 1.5 ? segmentStartPx : segmentEndPx;\\n  // if angle is too high, do not make a proper join\\n  if (cos(angle) > \").concat(LINESTRING_ANGLE_COSINE_CUTOFF, \" || isCap(angle)) {\\n    joinDirection = normalPx * normalDir - tangentPx * tangentDir;\\n  } else {\\n    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);\\n  }\\n  positionPx = positionPx + joinDirection * lineWidth * 0.5;\\n  gl_Position = pxToScreen(positionPx);\\n\\n  v_segmentStart = segmentStartPx;\\n  v_segmentEnd = segmentEndPx;\\n  v_width = lineWidth;\\n  v_hitColor = a_hitColor;\\n  v_distanceOffsetPx = a_distance / u_resolution - (lineOffsetPx * angleTangentSum);\\n\").concat(this.varyings_.map(function (varying) {\n      return '  ' + varying.name + ' = ' + varying.expression + ';';\n    }).join('\\n'), \"\\n}\");\n  }\n\n  /**\n   * Generates a stroke fragment shader from the builder parameters\n   *\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getStrokeFragmentShader() {\n    if (!this.hasStroke_) {\n      return null;\n    }\n    return \"\".concat(COMMON_HEADER, \"\\n\").concat(this.uniforms_.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n'), \"\\nvarying vec2 v_segmentStart;\\nvarying vec2 v_segmentEnd;\\nvarying float v_angleStart;\\nvarying float v_angleEnd;\\nvarying float v_width;\\nvarying vec4 v_hitColor;\\nvarying float v_distanceOffsetPx;\\n\").concat(this.varyings_.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n'), \"\\n\").concat(this.fragmentShaderFunctions_.join('\\n'), \"\\n\\nvec2 pxToWorld(vec2 pxPos) {\\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\\n}\\n\\nbool isCap(float joinAngle) {\\n  return joinAngle < -0.1;\\n}\\n\\nfloat segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {\\n  vec2 tangent = normalize(end - start);\\n  vec2 normal = vec2(-tangent.y, tangent.x);\\n  vec2 startToPoint = point - start;\\n  return abs(dot(startToPoint, normal)) - width * 0.5;\\n}\\n\\nfloat buttCapDistanceField(vec2 point, vec2 start, vec2 end) {\\n  vec2 startToPoint = point - start;\\n  vec2 tangent = normalize(end - start);\\n  return dot(startToPoint, -tangent);\\n}\\n\\nfloat squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {\\n  return buttCapDistanceField(point, start, end) - width * 0.5;\\n}\\n\\nfloat roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {\\n  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment\\n  return length(point - start) - width * 0.5 - onSegment;\\n}\\n\\nfloat roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {\\n  return roundCapDistanceField(point, start, end, width);\\n}\\n\\nfloat bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {\\n  vec2 startToPoint = point - start;\\n  vec2 tangent = normalize(end - start);\\n  float c = cos(joinAngle * 0.5);\\n  float s = sin(joinAngle * 0.5);\\n  float direction = -sign(sin(joinAngle));\\n  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);\\n  float radius = width * 0.5 * s;\\n  return dot(startToPoint, bisector * direction) - radius;\\n}\\n\\nfloat miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {\\n  if (cos(joinAngle) > \").concat(LINESTRING_ANGLE_COSINE_CUTOFF, \") { // avoid risking a division by zero\\n    return bevelJoinField(point, start, end, width, joinAngle);\\n  }\\n  float miterLength = 1. / sin(joinAngle * 0.5);\\n  float miterLimit = \").concat(this.strokeMiterLimitExpression_, \";\\n  if (miterLength > miterLimit) {\\n    return bevelJoinField(point, start, end, width, joinAngle);\\n  }\\n  return -1000.;\\n}\\n\\nfloat capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {\\n   if (capType == \").concat(stringToGlsl('butt'), \") {\\n    return buttCapDistanceField(point, start, end);\\n  } else if (capType == \").concat(stringToGlsl('square'), \") {\\n    return squareCapDistanceField(point, start, end, width);\\n  }\\n  return roundCapDistanceField(point, start, end, width);\\n}\\n\\nfloat joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {\\n  if (joinType == \").concat(stringToGlsl('bevel'), \") {\\n    return bevelJoinField(point, start, end, width, joinAngle);\\n  } else if (joinType == \").concat(stringToGlsl('miter'), \") {\\n    return miterJoinDistanceField(point, start, end, width, joinAngle);\\n  }\\n  return roundJoinDistanceField(point, start, end, width);\\n}\\n\\nfloat computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {\\n  if (isCap(joinAngle)) {\\n    return capDistanceField(point, start, end, width, capType);\\n  }\\n  return joinDistanceField(point, start, end, width, joinAngle, joinType);\\n}\\n\\nvoid main(void) {\\n  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;\\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\\n  vec2 worldPos = pxToWorld(currentPoint);\\n  if (\\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\\n      worldPos[0] < u_renderExtent[0] ||\\n      worldPos[1] < u_renderExtent[1] ||\\n      worldPos[0] > u_renderExtent[2] ||\\n      worldPos[1] > u_renderExtent[3]\\n    )\\n  ) {\\n    discard;\\n  }\\n  #endif\\n  if (\").concat(this.discardExpression_, \") { discard; }\\n\\n  float segmentLength = length(v_segmentEnd - v_segmentStart);\\n  vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;\\n  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);\\n  vec2 startToPoint = currentPoint - v_segmentStart;\\n  float currentLengthPx = max(0., min(dot(segmentTangent, startToPoint), segmentLength)) + v_distanceOffsetPx; \\n  float currentRadiusPx = abs(dot(segmentNormal, startToPoint));\\n  float currentRadiusRatio = dot(segmentNormal, startToPoint) * 2. / v_width;\\n  vec4 color = \").concat(this.strokeColorExpression_, \" * u_globalAlpha;\\n  float capType = \").concat(this.strokeCapExpression_, \";\\n  float joinType = \").concat(this.strokeJoinExpression_, \";\\n  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, v_width, v_angleStart, capType, joinType);\\n  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, v_width, v_angleEnd, capType, joinType);\\n  float distance = max(\\n    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, v_width),\\n    max(segmentStartDistance, segmentEndDistance)\\n  );\\n  distance = max(distance, \").concat(this.strokeDistanceFieldExpression_, \");\\n  gl_FragColor = color * smoothstep(0., -1., distance);\\n  if (u_hitDetection > 0) {\\n    if (gl_FragColor.a < 0.1) { discard; };\\n    gl_FragColor = v_hitColor;\\n  }\\n}\");\n  }\n\n  /**\n   * Generates a fill vertex shader from the builder parameters\n   *\n   * @return {string|null} The full shader as a string; null if no color specified\n   */\n  getFillVertexShader() {\n    if (!this.hasFill_) {\n      return null;\n    }\n    return \"\".concat(COMMON_HEADER, \"\\n\").concat(this.uniforms_.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n'), \"\\nattribute vec2 a_position;\\nattribute vec4 a_hitColor;\\n\").concat(this.attributes_.map(function (attribute) {\n      return 'attribute ' + attribute + ';';\n    }).join('\\n'), \"\\nvarying vec4 v_hitColor;\\n\").concat(this.varyings_.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n'), \"\\n\").concat(this.vertexShaderFunctions_.join('\\n'), \"\\nvoid main(void) {\\n  gl_Position = u_projectionMatrix * vec4(a_position, u_depth, 1.0);\\n  v_hitColor = a_hitColor;\\n\").concat(this.varyings_.map(function (varying) {\n      return '  ' + varying.name + ' = ' + varying.expression + ';';\n    }).join('\\n'), \"\\n}\");\n  }\n\n  /**\n   * Generates a fill fragment shader from the builder parameters\n   * @return {string|null} The full shader as a string; null if no color specified\n   */\n  getFillFragmentShader() {\n    if (!this.hasFill_) {\n      return null;\n    }\n    return \"\".concat(COMMON_HEADER, \"\\n\").concat(this.uniforms_.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n'), \"\\nvarying vec4 v_hitColor;\\n\").concat(this.varyings_.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n'), \"\\n\").concat(this.fragmentShaderFunctions_.join('\\n'), \"\\nvec2 pxToWorld(vec2 pxPos) {\\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\\n}\\n\\nvec2 worldToPx(vec2 worldPos) {\\n  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\\n  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;\\n}\\n\\nvoid main(void) {\\n  vec2 pxPos = gl_FragCoord.xy / u_pixelRatio;\\n  vec2 pxOrigin = worldToPx(u_patternOrigin);\\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\\n  vec2 worldPos = pxToWorld(pxPos);\\n  if (\\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\\n      worldPos[0] < u_renderExtent[0] ||\\n      worldPos[1] < u_renderExtent[1] ||\\n      worldPos[0] > u_renderExtent[2] ||\\n      worldPos[1] > u_renderExtent[3]\\n    )\\n  ) {\\n    discard;\\n  }\\n  #endif\\n  if (\").concat(this.discardExpression_, \") { discard; }\\n  gl_FragColor = \").concat(this.fillColorExpression_, \" * u_globalAlpha;\\n  if (u_hitDetection > 0) {\\n    if (gl_FragColor.a < 0.1) { discard; };\\n    gl_FragColor = v_hitColor;\\n  }\\n}\");\n  }\n}","map":{"version":3,"names":["LINESTRING_ANGLE_COSINE_CUTOFF","colorToGlsl","numberToGlsl","stringToGlsl","createDefaultStyle","COMMON_HEADER","DEFAULT_STYLE","ShaderBuilder","constructor","uniforms_","attributes_","varyings_","hasSymbol_","symbolSizeExpression_","concat","symbolRotationExpression_","symbolOffsetExpression_","symbolColorExpression_","texCoordExpression_","discardExpression_","symbolRotateWithView_","hasStroke_","strokeWidthExpression_","strokeColorExpression_","strokeOffsetExpression_","strokeCapExpression_","strokeJoinExpression_","strokeMiterLimitExpression_","strokeDistanceFieldExpression_","hasFill_","fillColorExpression_","vertexShaderFunctions_","fragmentShaderFunctions_","addUniform","name","push","addAttribute","addVarying","type","expression","setSymbolSizeExpression","getSymbolSizeExpression","setSymbolRotationExpression","setSymbolOffsetExpression","getSymbolOffsetExpression","setSymbolColorExpression","getSymbolColorExpression","setTextureCoordinateExpression","setFragmentDiscardExpression","getFragmentDiscardExpression","setSymbolRotateWithView","rotateWithView","setStrokeWidthExpression","setStrokeColorExpression","getStrokeColorExpression","setStrokeOffsetExpression","setStrokeCapExpression","setStrokeJoinExpression","setStrokeMiterLimitExpression","setStrokeDistanceFieldExpression","setFillColorExpression","getFillColorExpression","addVertexShaderFunction","code","includes","addFragmentShaderFunction","getSymbolVertexShader","map","uniform","join","attribute","varying","getSymbolFragmentShader","getStrokeVertexShader","getStrokeFragmentShader","getFillVertexShader","getFillFragmentShader"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/webgl/ShaderBuilder.js"],"sourcesContent":["/**\n * Class for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\nimport {LINESTRING_ANGLE_COSINE_CUTOFF} from '../render/webgl/utils.js';\nimport {colorToGlsl, numberToGlsl, stringToGlsl} from '../expr/gpu.js';\nimport {createDefaultStyle} from '../style/flat.js';\n\nexport const COMMON_HEADER = `#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_screenToWorldMatrix;\nuniform vec2 u_viewportSizePx;\nuniform float u_pixelRatio;\nuniform float u_globalAlpha;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\nuniform float u_rotation;\nuniform vec4 u_renderExtent;\nuniform vec2 u_patternOrigin;\nuniform float u_depth;\nuniform mediump int u_hitDetection;\n\nconst float PI = 3.141592653589793238;\nconst float TWO_PI = 2.0 * PI;\n\n// this used to produce an alpha-premultiplied color from a texture\nvec4 samplePremultiplied(sampler2D sampler, vec2 texCoord) {\n  vec4 color = texture2D(sampler, texCoord);\n  return vec4(color.rgb * color.a, color.a);\n}\n`;\n\nconst DEFAULT_STYLE = createDefaultStyle();\n\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSymbolSizeExpression('...')\n *   .getSymbolFragmentShader();\n * ```\n */\nexport class ShaderBuilder {\n  constructor() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms_ = [];\n\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.attributes_ = [];\n\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n    this.varyings_ = [];\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasSymbol_ = false;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolSizeExpression_ = `vec2(${numberToGlsl(\n      DEFAULT_STYLE['circle-radius']\n    )} + ${numberToGlsl(DEFAULT_STYLE['circle-stroke-width'] * 0.5)})`;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolRotationExpression_ = '0.0';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolOffsetExpression_ = 'vec2(0.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.symbolColorExpression_ = colorToGlsl(\n      /** @type {string} */ (DEFAULT_STYLE['circle-fill-color'])\n    );\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.texCoordExpression_ = 'vec4(0.0, 0.0, 1.0, 1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.discardExpression_ = 'false';\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.symbolRotateWithView_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasStroke_ = false;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.strokeWidthExpression_ = numberToGlsl(DEFAULT_STYLE['stroke-width']);\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.strokeColorExpression_ = colorToGlsl(\n      /** @type {string} */ (DEFAULT_STYLE['stroke-color'])\n    );\n\n    /**\n     * @private\n     */\n    this.strokeOffsetExpression_ = '0.';\n\n    /**\n     * @private\n     */\n    this.strokeCapExpression_ = stringToGlsl('round');\n\n    /**\n     * @private\n     */\n    this.strokeJoinExpression_ = stringToGlsl('round');\n\n    /**\n     * @private\n     */\n    this.strokeMiterLimitExpression_ = '10.';\n\n    /**\n     * @private\n     */\n    this.strokeDistanceFieldExpression_ = '-1000.';\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasFill_ = false;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.fillColorExpression_ = colorToGlsl(\n      /** @type {string} */ (DEFAULT_STYLE['fill-color'])\n    );\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.vertexShaderFunctions_ = [];\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.fragmentShaderFunctions_ = [];\n  }\n\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n  addUniform(name) {\n    this.uniforms_.push(name);\n    return this;\n  }\n\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n  addAttribute(name) {\n    this.attributes_.push(name);\n    return this;\n  }\n\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n  addVarying(name, type, expression) {\n    this.varyings_.push({\n      name: name,\n      type: type,\n      expression: expression,\n    });\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolSizeExpression(expression) {\n    this.hasSymbol_ = true;\n    this.symbolSizeExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current symbol size expression\n   */\n  getSymbolSizeExpression() {\n    return this.symbolSizeExpression_;\n  }\n\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolRotationExpression(expression) {\n    this.symbolRotationExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolOffsetExpression(expression) {\n    this.symbolOffsetExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current symbol offset expression\n   */\n  getSymbolOffsetExpression() {\n    return this.symbolOffsetExpression_;\n  }\n\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolColorExpression(expression) {\n    this.hasSymbol_ = true;\n    this.symbolColorExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current symbol color expression\n   */\n  getSymbolColorExpression() {\n    return this.symbolColorExpression_;\n  }\n\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setTextureCoordinateExpression(expression) {\n    this.texCoordExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setFragmentDiscardExpression(expression) {\n    this.discardExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current fragment discard expression\n   */\n  getFragmentDiscardExpression() {\n    return this.discardExpression_;\n  }\n\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolRotateWithView(rotateWithView) {\n    this.symbolRotateWithView_ = rotateWithView;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke width expression, returning value in pixels\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeWidthExpression(expression) {\n    this.hasStroke_ = true;\n    this.strokeWidthExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke color expression, evaluate to `vec4`: can rely on currentLengthPx and currentRadiusPx\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeColorExpression(expression) {\n    this.hasStroke_ = true;\n    this.strokeColorExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current stroke color expression\n   */\n  getStrokeColorExpression() {\n    return this.strokeColorExpression_;\n  }\n\n  /**\n   * @param {string} expression Stroke color expression, evaluate to `float`\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeOffsetExpression(expression) {\n    this.strokeOffsetExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke line cap expression, evaluate to `float`\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeCapExpression(expression) {\n    this.strokeCapExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke line join expression, evaluate to `float`\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeJoinExpression(expression) {\n    this.strokeJoinExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke miter limit expression, evaluate to `float`\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeMiterLimitExpression(expression) {\n    this.strokeMiterLimitExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Stroke distance field expression, evaluate to `float`\n   * This can override the default distance field; can rely on currentLengthPx and currentRadiusPx\n   * @return {ShaderBuilder} the builder object\n   */\n  setStrokeDistanceFieldExpression(expression) {\n    this.strokeDistanceFieldExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @param {string} expression Fill color expression, evaluate to `vec4`\n   * @return {ShaderBuilder} the builder object\n   */\n  setFillColorExpression(expression) {\n    this.hasFill_ = true;\n    this.fillColorExpression_ = expression;\n    return this;\n  }\n\n  /**\n   * @return {string} The current fill color expression\n   */\n  getFillColorExpression() {\n    return this.fillColorExpression_;\n  }\n\n  addVertexShaderFunction(code) {\n    if (this.vertexShaderFunctions_.includes(code)) {\n      return;\n    }\n    this.vertexShaderFunctions_.push(code);\n  }\n  addFragmentShaderFunction(code) {\n    if (this.fragmentShaderFunctions_.includes(code)) {\n      return;\n    }\n    this.fragmentShaderFunctions_.push(code);\n  }\n\n  /**\n   * Generates a symbol vertex shader from the builder parameters\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getSymbolVertexShader() {\n    if (!this.hasSymbol_) {\n      return null;\n    }\n\n    return `${COMMON_HEADER}\n${this.uniforms_\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nattribute vec2 a_position;\nattribute float a_index;\nattribute vec4 a_hitColor;\n${this.attributes_\n  .map(function (attribute) {\n    return 'attribute ' + attribute + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\nvarying vec4 v_hitColor;\nvarying vec2 v_centerPx;\nvarying float v_angle;\nvarying vec2 v_quadSizePx;\n${this.varyings_\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\n${this.vertexShaderFunctions_.join('\\n')}\nvec2 pxToScreen(vec2 coordPx) {\n  vec2 scaled = coordPx / u_viewportSizePx / 0.5;\n  return scaled;\n}\n\nvec2 screenToPx(vec2 coordScreen) {\n  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;\n}\n\nvoid main(void) {\n  v_quadSizePx = ${this.symbolSizeExpression_};\n  vec2 halfSizePx = v_quadSizePx * 0.5;\n  vec2 centerOffsetPx = ${this.symbolOffsetExpression_};\n  vec2 offsetPx = centerOffsetPx;\n  if (a_index == 0.0) {\n    offsetPx -= halfSizePx;\n  } else if (a_index == 1.0) {\n    offsetPx += halfSizePx * vec2(1., -1.);\n  } else if (a_index == 2.0) {\n    offsetPx += halfSizePx;\n  } else {\n    offsetPx += halfSizePx * vec2(-1., 1.);\n  }\n  float angle = ${this.symbolRotationExpression_};\n  ${this.symbolRotateWithView_ ? 'angle += u_rotation;' : ''}\n  float c = cos(-angle);\n  float s = sin(-angle);\n  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);\n  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n  gl_Position = center + vec4(pxToScreen(offsetPx), u_depth, 0.);\n  vec4 texCoord = ${this.texCoordExpression_};\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  v_hitColor = a_hitColor;\n  v_angle = angle;\n  c = cos(-v_angle);\n  s = sin(-v_angle);\n  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y); \n  v_centerPx = screenToPx(center.xy) + centerOffsetPx;\n${this.varyings_\n  .map(function (varying) {\n    return '  ' + varying.name + ' = ' + varying.expression + ';';\n  })\n  .join('\\n')}\n}`;\n  }\n\n  /**\n   * Generates a symbol fragment shader from the builder parameters\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getSymbolFragmentShader() {\n    if (!this.hasSymbol_) {\n      return null;\n    }\n\n    return `${COMMON_HEADER}\n${this.uniforms_\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec4 v_hitColor;\nvarying vec2 v_centerPx;\nvarying float v_angle;\nvarying vec2 v_quadSizePx;\n${this.varyings_\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\n${this.fragmentShaderFunctions_.join('\\n')}\n\nvoid main(void) {\n  if (${this.discardExpression_}) { discard; }\n  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center\n  float c = cos(v_angle);\n  float s = sin(v_angle);\n  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);\n  gl_FragColor = ${this.symbolColorExpression_};\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.05) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`;\n  }\n\n  /**\n   * Generates a stroke vertex shader from the builder parameters\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getStrokeVertexShader() {\n    if (!this.hasStroke_) {\n      return null;\n    }\n\n    return `${COMMON_HEADER}\n${this.uniforms_\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nattribute vec2 a_position;\nattribute float a_index;\nattribute vec2 a_segmentStart;\nattribute vec2 a_segmentEnd;\nattribute float a_parameters;\nattribute float a_distance;\nattribute vec2 a_joinAngles;\nattribute vec4 a_hitColor;\n${this.attributes_\n  .map(function (attribute) {\n    return 'attribute ' + attribute + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\nvarying float v_distanceOffsetPx;\n${this.varyings_\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\n${this.vertexShaderFunctions_.join('\\n')}\nvec2 worldToPx(vec2 worldPos) {\n  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\n  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;\n}\n\nvec4 pxToScreen(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return vec4(screenPos, u_depth, 1.0);\n}\n\nbool isCap(float joinAngle) {\n  return joinAngle < -0.1;\n}\n\nvec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {\n  float halfAngle = joinAngle / 2.0;\n  float c = cos(halfAngle);\n  float s = sin(halfAngle);\n  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);\n  float length = 1.0 / s;\n  return angleBisectorNormal * length;\n}\n\nvec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {\n  // if on a cap or the join angle is too high, offset the line along the segment normal\n  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {\n    return point - normal * offsetPx;\n  }\n  // offset is applied along the inverted normal (positive offset goes \"right\" relative to line direction)\n  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;\n}\n\nvoid main(void) {\n  v_angleStart = a_joinAngles.x;\n  v_angleEnd = a_joinAngles.y;\n  float vertexNumber = floor(abs(a_parameters) / 10000. + 0.5);\n  // we're reading the fractional part while keeping the sign (so -4.12 gives -0.12, 3.45 gives 0.45)\n  float angleTangentSum = fract(abs(a_parameters) / 10000.) * 10000. * sign(a_parameters);\n\n  float lineWidth = ${this.strokeWidthExpression_};\n  float lineOffsetPx = ${this.strokeOffsetExpression_};\n\n  // compute segment start/end in px with offset\n  vec2 segmentStartPx = worldToPx(a_segmentStart);\n  vec2 segmentEndPx = worldToPx(a_segmentEnd);\n  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);\n  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);\n  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),\n  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);\n  \n  // compute current vertex position\n  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;\n  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;\n  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;\n  vec2 joinDirection;\n  vec2 positionPx = vertexNumber < 1.5 ? segmentStartPx : segmentEndPx;\n  // if angle is too high, do not make a proper join\n  if (cos(angle) > ${LINESTRING_ANGLE_COSINE_CUTOFF} || isCap(angle)) {\n    joinDirection = normalPx * normalDir - tangentPx * tangentDir;\n  } else {\n    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);\n  }\n  positionPx = positionPx + joinDirection * lineWidth * 0.5;\n  gl_Position = pxToScreen(positionPx);\n\n  v_segmentStart = segmentStartPx;\n  v_segmentEnd = segmentEndPx;\n  v_width = lineWidth;\n  v_hitColor = a_hitColor;\n  v_distanceOffsetPx = a_distance / u_resolution - (lineOffsetPx * angleTangentSum);\n${this.varyings_\n  .map(function (varying) {\n    return '  ' + varying.name + ' = ' + varying.expression + ';';\n  })\n  .join('\\n')}\n}`;\n  }\n\n  /**\n   * Generates a stroke fragment shader from the builder parameters\n   *\n   * @return {string|null} The full shader as a string; null if no size or color specified\n   */\n  getStrokeFragmentShader() {\n    if (!this.hasStroke_) {\n      return null;\n    }\n\n    return `${COMMON_HEADER}\n${this.uniforms_\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\nvarying float v_distanceOffsetPx;\n${this.varyings_\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\n${this.fragmentShaderFunctions_.join('\\n')}\n\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nbool isCap(float joinAngle) {\n  return joinAngle < -0.1;\n}\n\nfloat segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  vec2 tangent = normalize(end - start);\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 startToPoint = point - start;\n  return abs(dot(startToPoint, normal)) - width * 0.5;\n}\n\nfloat buttCapDistanceField(vec2 point, vec2 start, vec2 end) {\n  vec2 startToPoint = point - start;\n  vec2 tangent = normalize(end - start);\n  return dot(startToPoint, -tangent);\n}\n\nfloat squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  return buttCapDistanceField(point, start, end) - width * 0.5;\n}\n\nfloat roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment\n  return length(point - start) - width * 0.5 - onSegment;\n}\n\nfloat roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  return roundCapDistanceField(point, start, end, width);\n}\n\nfloat bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {\n  vec2 startToPoint = point - start;\n  vec2 tangent = normalize(end - start);\n  float c = cos(joinAngle * 0.5);\n  float s = sin(joinAngle * 0.5);\n  float direction = -sign(sin(joinAngle));\n  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);\n  float radius = width * 0.5 * s;\n  return dot(startToPoint, bisector * direction) - radius;\n}\n\nfloat miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {\n  if (cos(joinAngle) > ${LINESTRING_ANGLE_COSINE_CUTOFF}) { // avoid risking a division by zero\n    return bevelJoinField(point, start, end, width, joinAngle);\n  }\n  float miterLength = 1. / sin(joinAngle * 0.5);\n  float miterLimit = ${this.strokeMiterLimitExpression_};\n  if (miterLength > miterLimit) {\n    return bevelJoinField(point, start, end, width, joinAngle);\n  }\n  return -1000.;\n}\n\nfloat capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {\n   if (capType == ${stringToGlsl('butt')}) {\n    return buttCapDistanceField(point, start, end);\n  } else if (capType == ${stringToGlsl('square')}) {\n    return squareCapDistanceField(point, start, end, width);\n  }\n  return roundCapDistanceField(point, start, end, width);\n}\n\nfloat joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {\n  if (joinType == ${stringToGlsl('bevel')}) {\n    return bevelJoinField(point, start, end, width, joinAngle);\n  } else if (joinType == ${stringToGlsl('miter')}) {\n    return miterJoinDistanceField(point, start, end, width, joinAngle);\n  }\n  return roundJoinDistanceField(point, start, end, width);\n}\n\nfloat computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {\n  if (isCap(joinAngle)) {\n    return capDistanceField(point, start, end, width, capType);\n  }\n  return joinDistanceField(point, start, end, width, joinAngle, joinType);\n}\n\nvoid main(void) {\n  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 worldPos = pxToWorld(currentPoint);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      worldPos[0] < u_renderExtent[0] ||\n      worldPos[1] < u_renderExtent[1] ||\n      worldPos[0] > u_renderExtent[2] ||\n      worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n  if (${this.discardExpression_}) { discard; }\n\n  float segmentLength = length(v_segmentEnd - v_segmentStart);\n  vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;\n  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);\n  vec2 startToPoint = currentPoint - v_segmentStart;\n  float currentLengthPx = max(0., min(dot(segmentTangent, startToPoint), segmentLength)) + v_distanceOffsetPx; \n  float currentRadiusPx = abs(dot(segmentNormal, startToPoint));\n  float currentRadiusRatio = dot(segmentNormal, startToPoint) * 2. / v_width;\n  vec4 color = ${this.strokeColorExpression_} * u_globalAlpha;\n  float capType = ${this.strokeCapExpression_};\n  float joinType = ${this.strokeJoinExpression_};\n  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, v_width, v_angleStart, capType, joinType);\n  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, v_width, v_angleEnd, capType, joinType);\n  float distance = max(\n    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, v_width),\n    max(segmentStartDistance, segmentEndDistance)\n  );\n  distance = max(distance, ${this.strokeDistanceFieldExpression_});\n  gl_FragColor = color * smoothstep(0., -1., distance);\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`;\n  }\n\n  /**\n   * Generates a fill vertex shader from the builder parameters\n   *\n   * @return {string|null} The full shader as a string; null if no color specified\n   */\n  getFillVertexShader() {\n    if (!this.hasFill_) {\n      return null;\n    }\n\n    return `${COMMON_HEADER}\n${this.uniforms_\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nattribute vec2 a_position;\nattribute vec4 a_hitColor;\n${this.attributes_\n  .map(function (attribute) {\n    return 'attribute ' + attribute + ';';\n  })\n  .join('\\n')}\nvarying vec4 v_hitColor;\n${this.varyings_\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\n${this.vertexShaderFunctions_.join('\\n')}\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, u_depth, 1.0);\n  v_hitColor = a_hitColor;\n${this.varyings_\n  .map(function (varying) {\n    return '  ' + varying.name + ' = ' + varying.expression + ';';\n  })\n  .join('\\n')}\n}`;\n  }\n\n  /**\n   * Generates a fill fragment shader from the builder parameters\n   * @return {string|null} The full shader as a string; null if no color specified\n   */\n  getFillFragmentShader() {\n    if (!this.hasFill_) {\n      return null;\n    }\n\n    return `${COMMON_HEADER}\n${this.uniforms_\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nvarying vec4 v_hitColor;\n${this.varyings_\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\n${this.fragmentShaderFunctions_.join('\\n')}\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nvec2 worldToPx(vec2 worldPos) {\n  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\n  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;\n}\n\nvoid main(void) {\n  vec2 pxPos = gl_FragCoord.xy / u_pixelRatio;\n  vec2 pxOrigin = worldToPx(u_patternOrigin);\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 worldPos = pxToWorld(pxPos);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      worldPos[0] < u_renderExtent[0] ||\n      worldPos[1] < u_renderExtent[1] ||\n      worldPos[0] > u_renderExtent[2] ||\n      worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n  if (${this.discardExpression_}) { discard; }\n  gl_FragColor = ${this.fillColorExpression_} * u_globalAlpha;\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}