{"ast":null,"code":"/**\n * @module ol/renderer/webgl/TileLayerBase\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport { abstract, getUid } from '../../util.js';\nimport { create as createMat4 } from '../../vec/mat4.js';\nimport { createOrUpdate as createTileCoord, getKey as getTileCoordKey } from '../../tilecoord.js';\nimport { create as createTransform, reset as resetTransform, rotate as rotateTransform, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\nimport { descending } from '../../array.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getIntersection, isEmpty } from '../../extent.js';\nimport { toSize } from '../../size.js';\nexport const Uniforms = {\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  RENDER_EXTENT: 'u_renderExtent',\n  // intersection of layer, source, and view extent\n  PATTERN_ORIGIN: 'u_patternOrigin',\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom',\n  GLOBAL_ALPHA: 'u_globalAlpha',\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix'\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst empty = {};\n\n/**\n * Transform a zoom level into a depth value; zoom level zero has a depth value of 0.5, and increasing values\n * have a depth trending towards 0\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n  return 1 / (z + 2);\n}\n\n/**\n * @typedef {import(\"../../webgl/BaseTileRepresentation.js\").default<import(\"../../Tile.js\").default>} AbstractTileRepresentation\n */\n/**\n * @typedef {Object} TileRepresentationLookup\n * @property {Set<string>} tileIds The set of tile ids in the lookup.\n * @property {Object<number, Set<AbstractTileRepresentation>>} representationsByZ Tile representations by zoom level.\n */\n\n/**\n * @return {TileRepresentationLookup} A new tile representation lookup.\n */\nexport function newTileRepresentationLookup() {\n  return {\n    tileIds: new Set(),\n    representationsByZ: {}\n  };\n}\n\n/**\n * Check if a tile is already in the tile representation lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @return {boolean} The tile is already in the lookup.\n */\nfunction lookupHasTile(tileRepresentationLookup, tile) {\n  return tileRepresentationLookup.tileIds.has(getUid(tile));\n}\n\n/**\n * Add a tile representation to the lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {AbstractTileRepresentation} tileRepresentation A tile representation.\n * @param {number} z The zoom level.\n */\nfunction addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, z) {\n  const representationsByZ = tileRepresentationLookup.representationsByZ;\n  if (!(z in representationsByZ)) {\n    representationsByZ[z] = new Set();\n  }\n  representationsByZ[z].add(tileRepresentation);\n  tileRepresentationLookup.tileIds.add(getUid(tileRepresentation.tile));\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */\n  layerState.layer.getRenderSource();\n  if (!source.getWrapX()) {\n    const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\nexport function getCacheKey(source, tileCoord) {\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\n}\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {number} [cacheSize=512] The tile representation cache size.\n * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.\n */\n\n/**\n * @typedef {import(\"../../layer/BaseTile.js\").default} BaseLayerType\n */\n\n/**\n * @classdesc\n * Base WebGL renderer for tile layers.\n * @template {BaseLayerType} LayerType\n * @template {import(\"../../Tile.js\").default} TileType\n * @template {import(\"../../webgl/BaseTileRepresentation.js\").default<TileType>} TileRepresentation\n * @extends {WebGLLayerRenderer<LayerType>}\n */\nclass WebGLBaseTileLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, {\n      uniforms: options.uniforms,\n      postProcesses: options.postProcesses\n    });\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * This transform converts representation coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.tileTransform_ = createTransform();\n\n    /**\n     * @type {Array<number>}\n     * @protected\n     */\n    this.tempMat4 = createMat4();\n\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n    this.tempSize_ = [0, 0];\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<TileRepresentation>}\n     * @protected\n     */\n    this.tileRepresentationCache = new LRUCache(cacheSize);\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.projection_ = undefined;\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset({\n      uniforms: options.uniforms\n    });\n  }\n\n  /**\n   * @param {TileType} tile Tile.\n   * @return {boolean} Tile is drawable.\n   * @private\n   */\n  isDrawableTile_(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.projection_) {\n      this.projection_ = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.projection_) {\n      this.clearCache();\n      this.projection_ = frameState.viewState.projection;\n    }\n    const layer = this.getLayer();\n    const source = layer.getRenderSource();\n    if (!source) {\n      return false;\n    }\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n    return source.getState() === 'ready';\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../../webgl/BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options tile representation options\n   * @return {TileRepresentation} A new tile representation\n   * @protected\n   */\n  createTileRepresentation(options) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tileRepresentationLookup, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileRepresentationCache = this.tileRepresentationCache;\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(initialZ - preload, tileGrid.getMinZoom(), tileGrid.getZForResolution(Math.min(tileLayer.getMaxResolution(), map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)), tileSource.zDirection));\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);\n      const tileResolution = tileGrid.getResolution(z);\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n          const cacheKey = getCacheKey(tileSource, tileCoord);\n\n          /** @type {TileRepresentation} */\n          let tileRepresentation;\n\n          /** @type {TileType} */\n          let tile;\n          if (tileRepresentationCache.containsKey(cacheKey)) {\n            tileRepresentation = tileRepresentationCache.get(cacheKey);\n            tile = tileRepresentation.tile;\n          }\n          if (!tileRepresentation || tileRepresentation.tile.key !== tileSource.getKey()) {\n            tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);\n          }\n          if (lookupHasTile(tileRepresentationLookup, tile)) {\n            continue;\n          }\n          if (!tileRepresentation) {\n            tileRepresentation = this.createTileRepresentation({\n              tile: tile,\n              grid: tileGrid,\n              helper: this.helper,\n              gutter: gutter\n            });\n            tileRepresentationCache.set(cacheKey, tileRepresentation);\n          } else {\n            if (this.isDrawableTile_(tile)) {\n              tileRepresentation.setTile(tile);\n            } else {\n              const interimTile = /** @type {TileType} */\n              tile.getInterimTile();\n              tileRepresentation.setTile(interimTile);\n            }\n          }\n          addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, z);\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileCoord), tileResolution]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha\n   * @protected\n   */\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    this.helper.prepareDraw(this.frameState, !tilesWithAlpha, true);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} If returns false, tile mask rendering will be skipped\n   * @protected\n   */\n  beforeTilesMaskRender(frameState) {\n    return false;\n  }\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {import(\"../../transform.js\").Transform} tileTransform Tile transform\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n   * @param {import(\"../../extent.js\").Extent} renderExtent Render extent\n   * @param {number} tileResolution Tile resolution\n   * @param {import(\"../../size.js\").Size} tileSize Tile size\n   * @param {import(\"../../coordinate.js\").Coordinate} tileOrigin Tile origin\n   * @param {import(\"../../extent.js\").Extent} tileExtent tile Extent\n   * @param {number} depth Depth\n   * @param {number} gutter Gutter\n   * @param {number} alpha Alpha\n   * @protected\n   */\n  renderTile(tileRepresentation, tileTransform, frameState, renderExtent, tileResolution, tileSize, tileOrigin, tileExtent, depth, gutter, alpha) {}\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {number} tileZ Tile Z\n   * @param {import(\"../../extent.js\").Extent} extent Render extent\n   * @param {number} depth Depth\n   * @protected\n   */\n  renderTileMask(tileRepresentation, tileZ, extent, depth) {}\n  drawTile_(frameState, tileRepresentation, tileZ, gutter, extent, alphaLookup, tileGrid) {\n    if (!tileRepresentation.ready) {\n      return;\n    }\n    const tile = tileRepresentation.tile;\n    const tileCoord = tile.tileCoord;\n    const tileCoordKey = getTileCoordKey(tileCoord);\n    const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n    const tileResolution = tileGrid.getResolution(tileZ);\n    const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n    const tileOrigin = tileGrid.getOrigin(tileZ);\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n    // tiles with alpha are rendered last to allow blending\n    const depth = alpha < 1 ? -1 : depthForZ(tileZ);\n    if (alpha < 1) {\n      frameState.animate = true;\n    }\n    const viewState = frameState.viewState;\n    const centerX = viewState.center[0];\n    const centerY = viewState.center[1];\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n    const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\n    const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n    const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n    const tileScale = viewState.resolution / tileResolution;\n    const tileCenterI = tileCoord[1];\n    const tileCenterJ = tileCoord[2];\n    resetTransform(this.tileTransform_);\n    scaleTransform(this.tileTransform_, 2 / (frameState.size[0] * tileScale / tileWidthWithGutter), -2 / (frameState.size[1] * tileScale / tileWidthWithGutter));\n    rotateTransform(this.tileTransform_, viewState.rotation);\n    scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\n    translateTransform(this.tileTransform_, (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter, (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter);\n    this.renderTile( /** @type {TileRepresentation} */tileRepresentation, this.tileTransform_, frameState, extent, tileResolution, tileSize, tileOrigin, tileExtent, depth, gutter, alpha);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    this.frameState = frameState;\n    this.renderComplete = true;\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const extent = getRenderExtent(frameState, frameState.extent);\n    const z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);\n\n    /**\n     * @type {TileRepresentationLookup}\n     */\n    const tileRepresentationLookup = newTileRepresentationLookup();\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tileRepresentationLookup, preload);\n    }\n    this.enqueueTiles(frameState, extent, z, tileRepresentationLookup, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(frameState, extent, z - 1, tileRepresentationLookup, preload - 1);\n      }, 0);\n    }\n\n    /**\n     * A lookup of alpha values for tiles at the target rendering resolution\n     * for tiles that are in transition.  If a tile coord key is absent from\n     * this lookup, the tile should be rendered at alpha 1.\n     * @type {Object<string, number>}\n     */\n    const alphaLookup = {};\n    const uid = getUid(this);\n    const time = frameState.time;\n    let blend = false;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tileRepresentation of tileRepresentationLookup.representationsByZ[z]) {\n      const tile = tileRepresentation.tile;\n      if ((tile instanceof ReprojTile || tile instanceof ReprojDataTile) && tile.getState() === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n      if (tileRepresentation.ready) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n        blend = true;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        alphaLookup[tileCoordKey] = alpha;\n      }\n      this.renderComplete = false;\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tileRepresentationLookup);\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileRepresentationLookup);\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n    const representationsByZ = tileRepresentationLookup.representationsByZ;\n    const zs = Object.keys(representationsByZ).map(Number).sort(descending);\n    const renderTileMask = this.beforeTilesMaskRender(frameState);\n    if (renderTileMask) {\n      for (let j = 0, jj = zs.length; j < jj; ++j) {\n        const tileZ = zs[j];\n        for (const tileRepresentation of representationsByZ[tileZ]) {\n          const tileCoord = tileRepresentation.tile.tileCoord;\n          const tileCoordKey = getTileCoordKey(tileCoord);\n          // do not render the tile mask if alpha < 1\n          if (tileCoordKey in alphaLookup) {\n            continue;\n          }\n          const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n          this.renderTileMask( /** @type {TileRepresentation} */tileRepresentation, tileZ, tileExtent, depthForZ(tileZ));\n        }\n      }\n    }\n    this.beforeTilesRender(frameState, blend);\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\n      const tileZ = zs[j];\n      for (const tileRepresentation of representationsByZ[tileZ]) {\n        const tileCoord = tileRepresentation.tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        if (tileCoordKey in alphaLookup) {\n          continue;\n        }\n        this.drawTile_(frameState, tileRepresentation, tileZ, gutter, extent, alphaLookup, tileGrid);\n      }\n    }\n    for (const tileRepresentation of representationsByZ[z]) {\n      const tileCoord = tileRepresentation.tile.tileCoord;\n      const tileCoordKey = getTileCoordKey(tileCoord);\n      if (tileCoordKey in alphaLookup) {\n        this.drawTile_(frameState, tileRepresentation, z, gutter, extent, alphaLookup, tileGrid);\n      }\n    }\n    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n    const canvas = this.helper.getCanvas();\n    const tileRepresentationCache = this.tileRepresentationCache;\n    while (tileRepresentationCache.canExpireCache()) {\n      const tileRepresentation = tileRepresentationCache.pop();\n      tileRepresentation.dispose();\n    }\n\n    // TODO: let the renderers manage their own cache instead of managing the source cache\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = function (map, frameState) {\n      tileSource.updateCacheSize(0.1, frameState.viewState.projection);\n      tileSource.expireCache(frameState.viewState.projection, empty);\n    };\n    frameState.postRenderFunctions.push(postRenderFunction);\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile representation lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of\n   * tile representations by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tileRepresentationLookup) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);\n    if (!tileRange) {\n      return false;\n    }\n    let covered = true;\n    const tileRepresentationCache = this.tileRepresentationCache;\n    const source = this.getLayer().getRenderSource();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\n        let loaded = false;\n        if (tileRepresentationCache.containsKey(cacheKey)) {\n          const tileRepresentation = tileRepresentationCache.get(cacheKey);\n          if (tileRepresentation.ready && !lookupHasTile(tileRepresentationLookup, tileRepresentation.tile)) {\n            addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n  clearCache() {\n    const tileRepresentationCache = this.tileRepresentationCache;\n    tileRepresentationCache.forEach(tileRepresentation => tileRepresentation.dispose());\n    tileRepresentationCache.clear();\n  }\n  removeHelper() {\n    if (this.helper) {\n      this.clearCache();\n    }\n    super.removeHelper();\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    super.disposeInternal();\n    delete this.frameState;\n  }\n}\nexport default WebGLBaseTileLayerRenderer;","map":{"version":3,"names":["LRUCache","ReprojDataTile","ReprojTile","TileRange","TileState","WebGLLayerRenderer","abstract","getUid","create","createMat4","createOrUpdate","createTileCoord","getKey","getTileCoordKey","createTransform","reset","resetTransform","rotate","rotateTransform","scale","scaleTransform","translate","translateTransform","descending","fromUserExtent","getIntersection","isEmpty","toSize","Uniforms","TILE_TRANSFORM","TRANSITION_ALPHA","DEPTH","RENDER_EXTENT","PATTERN_ORIGIN","RESOLUTION","ZOOM","GLOBAL_ALPHA","PROJECTION_MATRIX","SCREEN_TO_WORLD_MATRIX","empty","depthForZ","z","newTileRepresentationLookup","tileIds","Set","representationsByZ","lookupHasTile","tileRepresentationLookup","tile","has","addTileRepresentationToLookup","tileRepresentation","add","getRenderExtent","frameState","extent","layerState","layerStatesArray","layerIndex","viewState","projection","source","layer","getRenderSource","getWrapX","gridExtent","getTileGridForProjection","getExtent","getCacheKey","tileCoord","WebGLBaseTileLayerRenderer","constructor","tileLayer","options","uniforms","postProcesses","renderComplete","tileTransform_","tempMat4","tempTileRange_","tempTileCoord_","tempSize_","cacheSize","undefined","tileRepresentationCache","projection_","isDrawableTile_","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","prepareFrameInternal","clearCache","createTileRepresentation","enqueueTiles","initialZ","preload","tileSource","tileGrid","gutter","getGutterForProjection","tileSourceKey","wantedTiles","map","getMapInternal","minZ","Math","max","getMinZoom","getZForResolution","min","getMaxResolution","getView","getResolutionForZoom","getResolution","zDirection","tileRange","getTileRangeForExtentAndZ","tileResolution","x","minX","maxX","y","minY","maxY","cacheKey","containsKey","get","key","getTile","pixelRatio","grid","helper","set","setTile","interimTile","getInterimTile","tileQueueKey","IDLE","tileQueue","isKeyQueued","enqueue","getTileCoordCenter","beforeTilesRender","tilesWithAlpha","prepareDraw","beforeTilesMaskRender","renderTile","tileTransform","renderExtent","tileSize","tileOrigin","tileExtent","depth","alpha","renderTileMask","tileZ","drawTile_","alphaLookup","ready","tileCoordKey","getTileSize","getOrigin","getTileCoordExtent","animate","centerX","center","centerY","tileWidthWithGutter","tileHeightWithGutter","aspectRatio","centerI","centerJ","tileScale","resolution","tileCenterI","tileCenterJ","size","rotation","renderFrame","gl","getGL","preRender","getPreload","nextExtent","targetZ","nextResolution","setTimeout","uid","time","blend","getAlpha","endTransition","coveredByChildren","findAltTiles_","minZoom","parentZ","coveredByParent","zs","Object","keys","Number","sort","j","jj","length","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","canvas","getCanvas","canExpireCache","pop","dispose","postRenderFunction","updateCacheSize","expireCache","postRenderFunctions","push","postRender","altZ","getTileRangeForTileCoordAndZ","covered","loaded","forEach","clear","removeHelper","disposeInternal"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/renderer/webgl/TileLayerBase.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/TileLayerBase\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {abstract, getUid} from '../../util.js';\nimport {create as createMat4} from '../../vec/mat4.js';\nimport {\n  createOrUpdate as createTileCoord,\n  getKey as getTileCoordKey,\n} from '../../tilecoord.js';\nimport {\n  create as createTransform,\n  reset as resetTransform,\n  rotate as rotateTransform,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {descending} from '../../array.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getIntersection, isEmpty} from '../../extent.js';\nimport {toSize} from '../../size.js';\n\nexport const Uniforms = {\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  PATTERN_ORIGIN: 'u_patternOrigin',\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom',\n  GLOBAL_ALPHA: 'u_globalAlpha',\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst empty = {};\n\n/**\n * Transform a zoom level into a depth value; zoom level zero has a depth value of 0.5, and increasing values\n * have a depth trending towards 0\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n  return 1 / (z + 2);\n}\n\n/**\n * @typedef {import(\"../../webgl/BaseTileRepresentation.js\").default<import(\"../../Tile.js\").default>} AbstractTileRepresentation\n */\n/**\n * @typedef {Object} TileRepresentationLookup\n * @property {Set<string>} tileIds The set of tile ids in the lookup.\n * @property {Object<number, Set<AbstractTileRepresentation>>} representationsByZ Tile representations by zoom level.\n */\n\n/**\n * @return {TileRepresentationLookup} A new tile representation lookup.\n */\nexport function newTileRepresentationLookup() {\n  return {tileIds: new Set(), representationsByZ: {}};\n}\n\n/**\n * Check if a tile is already in the tile representation lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @return {boolean} The tile is already in the lookup.\n */\nfunction lookupHasTile(tileRepresentationLookup, tile) {\n  return tileRepresentationLookup.tileIds.has(getUid(tile));\n}\n\n/**\n * Add a tile representation to the lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {AbstractTileRepresentation} tileRepresentation A tile representation.\n * @param {number} z The zoom level.\n */\nfunction addTileRepresentationToLookup(\n  tileRepresentationLookup,\n  tileRepresentation,\n  z\n) {\n  const representationsByZ = tileRepresentationLookup.representationsByZ;\n  if (!(z in representationsByZ)) {\n    representationsByZ[z] = new Set();\n  }\n  representationsByZ[z].add(tileRepresentation);\n  tileRepresentationLookup.tileIds.add(getUid(tileRepresentation.tile));\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection)\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\nexport function getCacheKey(source, tileCoord) {\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\n}\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {number} [cacheSize=512] The tile representation cache size.\n * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.\n */\n\n/**\n * @typedef {import(\"../../layer/BaseTile.js\").default} BaseLayerType\n */\n\n/**\n * @classdesc\n * Base WebGL renderer for tile layers.\n * @template {BaseLayerType} LayerType\n * @template {import(\"../../Tile.js\").default} TileType\n * @template {import(\"../../webgl/BaseTileRepresentation.js\").default<TileType>} TileRepresentation\n * @extends {WebGLLayerRenderer<LayerType>}\n */\nclass WebGLBaseTileLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, {\n      uniforms: options.uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * This transform converts representation coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.tileTransform_ = createTransform();\n\n    /**\n     * @type {Array<number>}\n     * @protected\n     */\n    this.tempMat4 = createMat4();\n\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n    this.tempSize_ = [0, 0];\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<TileRepresentation>}\n     * @protected\n     */\n    this.tileRepresentationCache = new LRUCache(cacheSize);\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.projection_ = undefined;\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset({\n      uniforms: options.uniforms,\n    });\n  }\n\n  /**\n   * @param {TileType} tile Tile.\n   * @return {boolean} Tile is drawable.\n   * @private\n   */\n  isDrawableTile_(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.projection_) {\n      this.projection_ = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.projection_) {\n      this.clearCache();\n      this.projection_ = frameState.viewState.projection;\n    }\n\n    const layer = this.getLayer();\n    const source = layer.getRenderSource();\n    if (!source) {\n      return false;\n    }\n\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n    return source.getState() === 'ready';\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../../webgl/BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options tile representation options\n   * @return {TileRepresentation} A new tile representation\n   * @protected\n   */\n  createTileRepresentation(options) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(\n    frameState,\n    extent,\n    initialZ,\n    tileRepresentationLookup,\n    preload\n  ) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileRepresentationCache = this.tileRepresentationCache;\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0)\n        ),\n        tileSource.zDirection\n      )\n    );\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n          const cacheKey = getCacheKey(tileSource, tileCoord);\n\n          /** @type {TileRepresentation} */\n          let tileRepresentation;\n\n          /** @type {TileType} */\n          let tile;\n\n          if (tileRepresentationCache.containsKey(cacheKey)) {\n            tileRepresentation = tileRepresentationCache.get(cacheKey);\n            tile = tileRepresentation.tile;\n          }\n          if (\n            !tileRepresentation ||\n            tileRepresentation.tile.key !== tileSource.getKey()\n          ) {\n            tile = tileSource.getTile(\n              z,\n              x,\n              y,\n              frameState.pixelRatio,\n              viewState.projection\n            );\n          }\n\n          if (lookupHasTile(tileRepresentationLookup, tile)) {\n            continue;\n          }\n\n          if (!tileRepresentation) {\n            tileRepresentation = this.createTileRepresentation({\n              tile: tile,\n              grid: tileGrid,\n              helper: this.helper,\n              gutter: gutter,\n            });\n            tileRepresentationCache.set(cacheKey, tileRepresentation);\n          } else {\n            if (this.isDrawableTile_(tile)) {\n              tileRepresentation.setTile(tile);\n            } else {\n              const interimTile = /** @type {TileType} */ (\n                tile.getInterimTile()\n              );\n              tileRepresentation.setTile(interimTile);\n            }\n          }\n\n          addTileRepresentationToLookup(\n            tileRepresentationLookup,\n            tileRepresentation,\n            z\n          );\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha\n   * @protected\n   */\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    this.helper.prepareDraw(this.frameState, !tilesWithAlpha, true);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} If returns false, tile mask rendering will be skipped\n   * @protected\n   */\n  beforeTilesMaskRender(frameState) {\n    return false;\n  }\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {import(\"../../transform.js\").Transform} tileTransform Tile transform\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n   * @param {import(\"../../extent.js\").Extent} renderExtent Render extent\n   * @param {number} tileResolution Tile resolution\n   * @param {import(\"../../size.js\").Size} tileSize Tile size\n   * @param {import(\"../../coordinate.js\").Coordinate} tileOrigin Tile origin\n   * @param {import(\"../../extent.js\").Extent} tileExtent tile Extent\n   * @param {number} depth Depth\n   * @param {number} gutter Gutter\n   * @param {number} alpha Alpha\n   * @protected\n   */\n  renderTile(\n    tileRepresentation,\n    tileTransform,\n    frameState,\n    renderExtent,\n    tileResolution,\n    tileSize,\n    tileOrigin,\n    tileExtent,\n    depth,\n    gutter,\n    alpha\n  ) {}\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {number} tileZ Tile Z\n   * @param {import(\"../../extent.js\").Extent} extent Render extent\n   * @param {number} depth Depth\n   * @protected\n   */\n  renderTileMask(tileRepresentation, tileZ, extent, depth) {}\n\n  drawTile_(\n    frameState,\n    tileRepresentation,\n    tileZ,\n    gutter,\n    extent,\n    alphaLookup,\n    tileGrid\n  ) {\n    if (!tileRepresentation.ready) {\n      return;\n    }\n    const tile = tileRepresentation.tile;\n    const tileCoord = tile.tileCoord;\n    const tileCoordKey = getTileCoordKey(tileCoord);\n    const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n\n    const tileResolution = tileGrid.getResolution(tileZ);\n    const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n    const tileOrigin = tileGrid.getOrigin(tileZ);\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n    // tiles with alpha are rendered last to allow blending\n    const depth = alpha < 1 ? -1 : depthForZ(tileZ);\n    if (alpha < 1) {\n      frameState.animate = true;\n    }\n\n    const viewState = frameState.viewState;\n    const centerX = viewState.center[0];\n    const centerY = viewState.center[1];\n\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n\n    const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\n\n    const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n    const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n\n    const tileScale = viewState.resolution / tileResolution;\n\n    const tileCenterI = tileCoord[1];\n    const tileCenterJ = tileCoord[2];\n\n    resetTransform(this.tileTransform_);\n    scaleTransform(\n      this.tileTransform_,\n      2 / ((frameState.size[0] * tileScale) / tileWidthWithGutter),\n      -2 / ((frameState.size[1] * tileScale) / tileWidthWithGutter)\n    );\n    rotateTransform(this.tileTransform_, viewState.rotation);\n    scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\n    translateTransform(\n      this.tileTransform_,\n      (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter,\n      (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter\n    );\n\n    this.renderTile(\n      /** @type {TileRepresentation} */ (tileRepresentation),\n      this.tileTransform_,\n      frameState,\n      extent,\n      tileResolution,\n      tileSize,\n      tileOrigin,\n      tileExtent,\n      depth,\n      gutter,\n      alpha\n    );\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    this.frameState = frameState;\n    this.renderComplete = true;\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const extent = getRenderExtent(frameState, frameState.extent);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection\n    );\n\n    /**\n     * @type {TileRepresentationLookup}\n     */\n    const tileRepresentationLookup = newTileRepresentationLookup();\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(\n        frameState,\n        nextExtent,\n        targetZ,\n        tileRepresentationLookup,\n        preload\n      );\n    }\n\n    this.enqueueTiles(frameState, extent, z, tileRepresentationLookup, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          extent,\n          z - 1,\n          tileRepresentationLookup,\n          preload - 1\n        );\n      }, 0);\n    }\n\n    /**\n     * A lookup of alpha values for tiles at the target rendering resolution\n     * for tiles that are in transition.  If a tile coord key is absent from\n     * this lookup, the tile should be rendered at alpha 1.\n     * @type {Object<string, number>}\n     */\n    const alphaLookup = {};\n\n    const uid = getUid(this);\n    const time = frameState.time;\n    let blend = false;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tileRepresentation of tileRepresentationLookup\n      .representationsByZ[z]) {\n      const tile = tileRepresentation.tile;\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tile.getState() === TileState.EMPTY\n      ) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileRepresentation.ready) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n        blend = true;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        alphaLookup[tileCoordKey] = alpha;\n      }\n      this.renderComplete = false;\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tileRepresentationLookup\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tileRepresentationLookup\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    const representationsByZ = tileRepresentationLookup.representationsByZ;\n    const zs = Object.keys(representationsByZ).map(Number).sort(descending);\n\n    const renderTileMask = this.beforeTilesMaskRender(frameState);\n\n    if (renderTileMask) {\n      for (let j = 0, jj = zs.length; j < jj; ++j) {\n        const tileZ = zs[j];\n        for (const tileRepresentation of representationsByZ[tileZ]) {\n          const tileCoord = tileRepresentation.tile.tileCoord;\n          const tileCoordKey = getTileCoordKey(tileCoord);\n          // do not render the tile mask if alpha < 1\n          if (tileCoordKey in alphaLookup) {\n            continue;\n          }\n          const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n          this.renderTileMask(\n            /** @type {TileRepresentation} */ (tileRepresentation),\n            tileZ,\n            tileExtent,\n            depthForZ(tileZ)\n          );\n        }\n      }\n    }\n\n    this.beforeTilesRender(frameState, blend);\n\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\n      const tileZ = zs[j];\n      for (const tileRepresentation of representationsByZ[tileZ]) {\n        const tileCoord = tileRepresentation.tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        if (tileCoordKey in alphaLookup) {\n          continue;\n        }\n\n        this.drawTile_(\n          frameState,\n          tileRepresentation,\n          tileZ,\n          gutter,\n          extent,\n          alphaLookup,\n          tileGrid\n        );\n      }\n    }\n\n    for (const tileRepresentation of representationsByZ[z]) {\n      const tileCoord = tileRepresentation.tile.tileCoord;\n      const tileCoordKey = getTileCoordKey(tileCoord);\n      if (tileCoordKey in alphaLookup) {\n        this.drawTile_(\n          frameState,\n          tileRepresentation,\n          z,\n          gutter,\n          extent,\n          alphaLookup,\n          tileGrid\n        );\n      }\n    }\n\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent\n    );\n\n    const canvas = this.helper.getCanvas();\n\n    const tileRepresentationCache = this.tileRepresentationCache;\n    while (tileRepresentationCache.canExpireCache()) {\n      const tileRepresentation = tileRepresentationCache.pop();\n      tileRepresentation.dispose();\n    }\n\n    // TODO: let the renderers manage their own cache instead of managing the source cache\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = function (map, frameState) {\n      tileSource.updateCacheSize(0.1, frameState.viewState.projection);\n      tileSource.expireCache(frameState.viewState.projection, empty);\n    };\n\n    frameState.postRenderFunctions.push(postRenderFunction);\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile representation lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of\n   * tile representations by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tileRepresentationLookup) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileRepresentationCache = this.tileRepresentationCache;\n    const source = this.getLayer().getRenderSource();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\n        let loaded = false;\n        if (tileRepresentationCache.containsKey(cacheKey)) {\n          const tileRepresentation = tileRepresentationCache.get(cacheKey);\n          if (\n            tileRepresentation.ready &&\n            !lookupHasTile(tileRepresentationLookup, tileRepresentation.tile)\n          ) {\n            addTileRepresentationToLookup(\n              tileRepresentationLookup,\n              tileRepresentation,\n              altZ\n            );\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  clearCache() {\n    const tileRepresentationCache = this.tileRepresentationCache;\n    tileRepresentationCache.forEach((tileRepresentation) =>\n      tileRepresentation.dispose()\n    );\n    tileRepresentationCache.clear();\n  }\n\n  removeHelper() {\n    if (this.helper) {\n      this.clearCache();\n    }\n\n    super.removeHelper();\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    super.disposeInternal();\n    delete this.frameState;\n  }\n}\n\nexport default WebGLBaseTileLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}