{"ast":null,"code":"import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(slices.map(slice => this.fetchSlice(slice, signal)));\n  }\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices.map(({\n          offset,\n          length\n        }) => `${offset}-${offset + length}`).join(',')}`\n      },\n      signal\n    });\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const {\n        type,\n        params\n      } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n      const data = await response.getData();\n      const {\n        start,\n        end,\n        total\n      } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start\n      }];\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map(slice => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength\n      }];\n    }\n  }\n  async fetchSlice(slice, signal) {\n    const {\n      offset,\n      length\n    } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`\n      },\n      signal\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n      const {\n        total\n      } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength\n      };\n    }\n  }\n  get fileSize() {\n    return this._fileSize;\n  }\n}\nfunction maybeWrapInBlockedSource(source, {\n  blockSize,\n  cacheSize\n}) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, {\n    blockSize,\n    cacheSize\n  });\n}\nexport function makeFetchSource(url, {\n  headers = {},\n  credentials,\n  maxRanges = 0,\n  allowFullFile = false,\n  ...blockOptions\n} = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeXHRSource(url, {\n  headers = {},\n  maxRanges = 0,\n  allowFullFile = false,\n  ...blockOptions\n} = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeHttpSource(url, {\n  headers = {},\n  maxRanges = 0,\n  allowFullFile = false,\n  ...blockOptions\n} = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeCustomSource(client, {\n  headers = {},\n  maxRanges = 0,\n  allowFullFile = false,\n  ...blockOptions\n} = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, {\n  forceXHR = false,\n  ...clientOptions\n} = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}","map":{"version":3,"names":["parseByteRanges","parseContentRange","parseContentType","BaseSource","BlockedSource","FetchClient","XHRClient","HttpClient","RemoteSource","constructor","client","headers","maxRanges","allowFullFile","_fileSize","fetch","slices","signal","length","fetchSlices","Promise","all","map","slice","fetchSlice","response","request","Range","offset","join","ok","Error","status","type","params","getHeader","byteRanges","getData","boundary","fileSize","data","start","end","total","first","others","concat","byteLength","maybeWrapInBlockedSource","source","blockSize","cacheSize","makeFetchSource","url","credentials","blockOptions","makeXHRSource","makeHttpSource","makeCustomSource","makeRemoteSource","forceXHR","clientOptions","XMLHttpRequest"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/geotiff/dist-module/source/remote.js"],"sourcesContent":["import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}