{"ast":null,"code":"/**\n * @module ol/source/GeoTIFF\n */\nimport DataTile from './DataTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport { Pool, globals as geotiffGlobals, fromBlob as tiffFromBlob, fromUrl as tiffFromUrl, fromUrls as tiffFromUrls } from 'geotiff';\nimport { Projection, get as getCachedProjection, toUserCoordinate, toUserExtent } from '../proj.js';\nimport { clamp } from '../math.js';\nimport { getCenter, getIntersection } from '../extent.js';\nimport { error as logError } from '../console.js';\nimport { fromCode as unitsFromCode } from '../proj/Units.js';\n\n/**\n * Determine if an image type is a mask.\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} The image is a mask.\n */\nfunction isMask(image) {\n  const fileDirectory = image.fileDirectory;\n  const type = fileDirectory.NewSubfileType || 0;\n  return (type & 4) === 4;\n}\n\n/**\n * @param {true|false|'auto'} preference The convertToRGB option.\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} Use the `image.readRGB()` method.\n */\nfunction readRGB(preference, image) {\n  if (!preference) {\n    return false;\n  }\n  if (preference === true) {\n    return true;\n  }\n  if (image.getSamplesPerPixel() !== 3) {\n    return false;\n  }\n  const interpretation = image.fileDirectory.PhotometricInterpretation;\n  const interpretations = geotiffGlobals.photometricInterpretations;\n  return interpretation === interpretations.CMYK || interpretation === interpretations.YCbCr || interpretation === interpretations.CIELab || interpretation === interpretations.ICCLab;\n}\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\n\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\nconst defaultTileSize = 256;\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\n\nlet workerPool;\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool();\n  }\n  return workerPool;\n}\n\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox();\n  } catch (_) {\n    return [0, 0, image.getWidth(), image.getHeight()];\n  }\n}\n\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch (_) {\n    return [0, image.getHeight()];\n  }\n}\n\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\nfunction getResolutions(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage);\n  } catch (_) {\n    return [referenceImage.getWidth() / image.getWidth(), referenceImage.getHeight() / image.getHeight()];\n  }\n}\n\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\nfunction getProjection(image) {\n  const geoKeys = image.geoKeys;\n  if (!geoKeys) {\n    return null;\n  }\n  if (geoKeys.ProjectedCSTypeGeoKey && geoKeys.ProjectedCSTypeGeoKey !== 32767) {\n    const code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units\n        });\n      }\n    }\n    return projection;\n  }\n  if (geoKeys.GeographicTypeGeoKey && geoKeys.GeographicTypeGeoKey !== 32767) {\n    const code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units\n        });\n      }\n    }\n    return projection;\n  }\n  return null;\n}\n\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    const requests = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n    return Promise.all(requests);\n  });\n}\n\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n  let request;\n  if (source.blob) {\n    request = tiffFromBlob(source.blob);\n  } else if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews, options);\n  } else {\n    request = tiffFromUrl(source.url, options);\n  }\n  return request.then(getImagesForTIFF);\n}\n\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    const length = expected.length;\n    if (!Array.isArray(got) || length != got.length) {\n      const error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n    for (let i = 0; i < length; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n    return;\n  }\n  got = /** @type {number} */got;\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n  return 0;\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n  return 255;\n}\n\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\n * CIELab, and ICCLab images will automatically be converted to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\n * will be read for projection information.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * **Note for users of the full build**: The `GeoTIFF` source requires the\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\n *\n * @api\n */\nclass GeoTIFFSource extends DataTile {\n  /**\n   * @param {Options} options Data tile options.\n   */\n  constructor(options) {\n    super({\n      state: 'loading',\n      tileGrid: null,\n      projection: options.projection || null,\n      opaque: options.opaque,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX\n    });\n\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n    this.sourceInfo_ = options.sources;\n    const numSources = this.sourceInfo_.length;\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.sourceOptions_ = options.sourceOptions;\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceImagery_ = new Array(numSources);\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceMasks_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.resolutionFactors_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.samplesPerPixel_;\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.nodataValues_;\n\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n    this.metadata_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.normalize_ = options.normalize !== false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.addAlpha_ = false;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {true|false|'auto'}\n     */\n    this.convertToRGB_ = options.convertToRGB || false;\n    this.setKey(this.sourceInfo_.map(source => source.url).join(','));\n    const self = this;\n    const requests = new Array(numSources);\n    for (let i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(this.sourceInfo_[i], this.sourceOptions_);\n    }\n    Promise.all(requests).then(function (sources) {\n      self.configure_(sources);\n    }).catch(function (error) {\n      logError(error);\n      self.error_ = error;\n      self.setState('error');\n    });\n  }\n\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Determine the projection of the images in this GeoTIFF.\n   * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey\n   * of each image in turn.\n   * You can override this method in a subclass to support more projections.\n   *\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   */\n  determineProjection(sources) {\n    const firstSource = sources[0];\n    for (let i = firstSource.length - 1; i >= 0; --i) {\n      const image = firstSource[i];\n      const projection = getProjection(image);\n      if (projection) {\n        this.projection = projection;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n   * must have the same internal tiled structure.\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   * @private\n   */\n  configure_(sources) {\n    let extent;\n    let origin;\n    let commonRenderTileSizes;\n    let commonSourceTileSizes;\n    let resolutions;\n    const samplesPerPixel = new Array(sources.length);\n    const nodataValues = new Array(sources.length);\n    const metadata = new Array(sources.length);\n    let minZoom = 0;\n    const sourceCount = sources.length;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const images = [];\n      const masks = [];\n      sources[sourceIndex].forEach(item => {\n        if (isMask(item)) {\n          masks.push(item);\n        } else {\n          images.push(item);\n        }\n      });\n      const imageCount = images.length;\n      if (masks.length > 0 && masks.length !== imageCount) {\n        throw new Error(`Expected one mask per image found ${masks.length} masks and ${imageCount} images`);\n      }\n      let sourceExtent;\n      let sourceOrigin;\n      const sourceTileSizes = new Array(imageCount);\n      const renderTileSizes = new Array(imageCount);\n      const sourceResolutions = new Array(imageCount);\n      nodataValues[sourceIndex] = new Array(imageCount);\n      metadata[sourceIndex] = new Array(imageCount);\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n        const image = images[imageIndex];\n        const nodataValue = image.getGDALNoData();\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\n        samplesPerPixel[sourceIndex] = wantedSamples ? wantedSamples.length : image.getSamplesPerPixel();\n        const level = imageCount - (imageIndex + 1);\n        if (!sourceExtent) {\n          sourceExtent = getBoundingBox(image);\n        }\n        if (!sourceOrigin) {\n          sourceOrigin = getOrigin(image);\n        }\n        const imageResolutions = getResolutions(image, images[0]);\n        sourceResolutions[level] = imageResolutions[0];\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n\n        // request larger blocks for untiled layouts\n        if (sourceTileSize[0] !== sourceTileSize[1] && sourceTileSize[1] < defaultTileSize) {\n          sourceTileSize[0] = defaultTileSize;\n          sourceTileSize[1] = defaultTileSize;\n        }\n        sourceTileSizes[level] = sourceTileSize;\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n        renderTileSizes[level] = [sourceTileSize[0], sourceTileSize[1] / aspectRatio];\n      }\n      if (!extent) {\n        extent = sourceExtent;\n      } else {\n        getIntersection(extent, sourceExtent, extent);\n      }\n      if (!origin) {\n        origin = sourceOrigin;\n      } else {\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\n      }\n      if (!resolutions) {\n        resolutions = sourceResolutions;\n        this.resolutionFactors_[sourceIndex] = 1;\n      } else {\n        if (resolutions.length - minZoom > sourceResolutions.length) {\n          minZoom = resolutions.length - sourceResolutions.length;\n        }\n        const resolutionFactor = resolutions[resolutions.length - 1] / sourceResolutions[sourceResolutions.length - 1];\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\n        const scaledSourceResolutions = sourceResolutions.map(resolution => resolution *= resolutionFactor);\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\n        assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.02, message, this.viewRejector);\n      }\n      if (!commonRenderTileSizes) {\n        commonRenderTileSizes = renderTileSizes;\n      } else {\n        assertEqual(commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length), renderTileSizes, 0.01, `Tile size mismatch for source ${sourceIndex}`, this.viewRejector);\n      }\n      if (!commonSourceTileSizes) {\n        commonSourceTileSizes = sourceTileSizes;\n      } else {\n        assertEqual(commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length), sourceTileSizes, 0, `Tile size mismatch for source ${sourceIndex}`, this.viewRejector);\n      }\n      this.sourceImagery_[sourceIndex] = images.reverse();\n      this.sourceMasks_[sourceIndex] = masks.reverse();\n    }\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n      const sourceImagery = this.sourceImagery_[i];\n      while (sourceImagery.length < resolutions.length) {\n        sourceImagery.unshift(undefined);\n      }\n    }\n    if (!this.getProjection()) {\n      this.determineProjection(sources);\n    }\n    this.samplesPerPixel_ = samplesPerPixel;\n    this.nodataValues_ = nodataValues;\n    this.metadata_ = metadata;\n\n    // decide if we need to add an alpha band to handle nodata\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      // option 1: source is configured with a nodata value\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n        this.addAlpha_ = true;\n        break;\n      }\n      if (this.sourceMasks_[sourceIndex].length) {\n        this.addAlpha_ = true;\n        break;\n      }\n      const values = nodataValues[sourceIndex];\n\n      // option 2: check image metadata for limited bands\n      const bands = this.sourceInfo_[sourceIndex].bands;\n      if (bands) {\n        for (let i = 0; i < bands.length; ++i) {\n          if (values[bands[i] - 1] !== null) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n        continue;\n      }\n\n      // option 3: check image metadata for all bands\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n        if (values[imageIndex] !== null) {\n          this.addAlpha_ = true;\n          break outer;\n        }\n      }\n    }\n    let bandCount = this.addAlpha_ ? 1 : 0;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      bandCount += samplesPerPixel[sourceIndex];\n    }\n    this.bandCount = bandCount;\n    const tileGrid = new TileGrid({\n      extent: extent,\n      minZoom: minZoom,\n      origin: origin,\n      resolutions: resolutions,\n      tileSizes: commonRenderTileSizes\n    });\n    this.tileGrid = tileGrid;\n    this.setTileSizes(commonSourceTileSizes);\n    this.setLoader(this.loadTile_.bind(this));\n    this.setState('ready');\n    const zoom = 1;\n    if (resolutions.length === 2) {\n      resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\n    } else if (resolutions.length === 1) {\n      resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\n    }\n    this.viewResolver({\n      showFullExtent: true,\n      projection: this.projection,\n      resolutions: resolutions,\n      center: toUserCoordinate(getCenter(extent), this.projection),\n      extent: toUserExtent(extent, this.projection),\n      zoom: zoom\n    });\n  }\n\n  /**\n   * @param {number} z The z tile index.\n   * @param {number} x The x tile index.\n   * @param {number} y The y tile index.\n   * @return {Promise} The composed tile data.\n   * @private\n   */\n  loadTile_(z, x, y) {\n    const sourceTileSize = this.getTileSize(z);\n    const sourceCount = this.sourceImagery_.length;\n    const requests = new Array(sourceCount * 2);\n    const nodataValues = this.nodataValues_;\n    const sourceInfo = this.sourceInfo_;\n    const pool = getWorkerPool();\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const source = sourceInfo[sourceIndex];\n      const resolutionFactor = this.resolutionFactors_[sourceIndex];\n      const pixelBounds = [Math.round(x * (sourceTileSize[0] * resolutionFactor)), Math.round(y * (sourceTileSize[1] * resolutionFactor)), Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)), Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor))];\n      const image = this.sourceImagery_[sourceIndex][z];\n      let samples;\n      if (source.bands) {\n        samples = source.bands.map(function (bandNumber) {\n          return bandNumber - 1;\n        });\n      }\n\n      /** @type {number|Array<number>} */\n      let fillValue;\n      if ('nodata' in source && source.nodata !== null) {\n        fillValue = source.nodata;\n      } else {\n        if (!samples) {\n          fillValue = nodataValues[sourceIndex];\n        } else {\n          fillValue = samples.map(function (sampleIndex) {\n            return nodataValues[sourceIndex][sampleIndex];\n          });\n        }\n      }\n      const readOptions = {\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: samples,\n        fillValue: fillValue,\n        pool: pool,\n        interleave: false\n      };\n      if (readRGB(this.convertToRGB_, image)) {\n        requests[sourceIndex] = image.readRGB(readOptions);\n      } else {\n        requests[sourceIndex] = image.readRasters(readOptions);\n      }\n\n      // requests after `sourceCount` are for mask data (if any)\n      const maskIndex = sourceCount + sourceIndex;\n      const mask = this.sourceMasks_[sourceIndex][z];\n      if (!mask) {\n        requests[maskIndex] = Promise.resolve(null);\n        continue;\n      }\n      requests[maskIndex] = mask.readRasters({\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: [0],\n        pool: pool,\n        interleave: false\n      });\n    }\n    return Promise.all(requests).then(this.composeTile_.bind(this, sourceTileSize)).catch(function (error) {\n      logError(error);\n      throw error;\n    });\n  }\n\n  /**\n   * @param {import(\"../size.js\").Size} sourceTileSize The source tile size.\n   * @param {Array} sourceSamples The source samples.\n   * @return {import(\"../DataTile.js\").Data} The composed tile data.\n   * @private\n   */\n  composeTile_(sourceTileSize, sourceSamples) {\n    const metadata = this.metadata_;\n    const sourceInfo = this.sourceInfo_;\n    const sourceCount = this.sourceImagery_.length;\n    const bandCount = this.bandCount;\n    const samplesPerPixel = this.samplesPerPixel_;\n    const nodataValues = this.nodataValues_;\n    const normalize = this.normalize_;\n    const addAlpha = this.addAlpha_;\n    const pixelCount = sourceTileSize[0] * sourceTileSize[1];\n    const dataLength = pixelCount * bandCount;\n\n    /** @type {Uint8Array|Float32Array} */\n    let data;\n    if (normalize) {\n      data = new Uint8Array(dataLength);\n    } else {\n      data = new Float32Array(dataLength);\n    }\n    let dataIndex = 0;\n    for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n      let transparent = addAlpha;\n      for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n        const source = sourceInfo[sourceIndex];\n        let min = source.min;\n        let max = source.max;\n        let gain, bias;\n        if (normalize) {\n          const stats = metadata[sourceIndex][0];\n          if (min === undefined) {\n            if (stats && STATISTICS_MINIMUM in stats) {\n              min = parseFloat(stats[STATISTICS_MINIMUM]);\n            } else {\n              min = getMinForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n          if (max === undefined) {\n            if (stats && STATISTICS_MAXIMUM in stats) {\n              max = parseFloat(stats[STATISTICS_MAXIMUM]);\n            } else {\n              max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n          gain = 255 / (max - min);\n          bias = -min * gain;\n        }\n        for (let sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {\n          const sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n          let value;\n          if (normalize) {\n            value = clamp(gain * sourceValue + bias, 0, 255);\n          } else {\n            value = sourceValue;\n          }\n          if (!addAlpha) {\n            data[dataIndex] = value;\n          } else {\n            let nodata = source.nodata;\n            if (nodata === undefined) {\n              let bandIndex;\n              if (source.bands) {\n                bandIndex = source.bands[sampleIndex] - 1;\n              } else {\n                bandIndex = sampleIndex;\n              }\n              nodata = nodataValues[sourceIndex][bandIndex];\n            }\n            const nodataIsNaN = isNaN(nodata);\n            if (!nodataIsNaN && sourceValue !== nodata || nodataIsNaN && !isNaN(sourceValue)) {\n              transparent = false;\n              data[dataIndex] = value;\n            }\n          }\n          dataIndex++;\n        }\n        if (!transparent) {\n          const maskIndex = sourceCount + sourceIndex;\n          const mask = sourceSamples[maskIndex];\n          if (mask && !mask[0][pixelIndex]) {\n            transparent = true;\n          }\n        }\n      }\n      if (addAlpha) {\n        if (!transparent) {\n          data[dataIndex] = 255;\n        }\n        dataIndex++;\n      }\n    }\n    return data;\n  }\n}\n\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\nexport default GeoTIFFSource;","map":{"version":3,"names":["DataTile","TileGrid","Pool","globals","geotiffGlobals","fromBlob","tiffFromBlob","fromUrl","tiffFromUrl","fromUrls","tiffFromUrls","Projection","get","getCachedProjection","toUserCoordinate","toUserExtent","clamp","getCenter","getIntersection","error","logError","fromCode","unitsFromCode","isMask","image","fileDirectory","type","NewSubfileType","readRGB","preference","getSamplesPerPixel","interpretation","PhotometricInterpretation","interpretations","photometricInterpretations","CMYK","YCbCr","CIELab","ICCLab","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","defaultTileSize","workerPool","getWorkerPool","getBoundingBox","_","getWidth","getHeight","getOrigin","slice","getResolutions","referenceImage","getResolution","getProjection","geoKeys","ProjectedCSTypeGeoKey","code","projection","units","ProjLinearUnitsGeoKey","GeographicTypeGeoKey","GeogAngularUnitsGeoKey","getImagesForTIFF","tiff","getImageCount","then","count","requests","Array","i","getImage","Promise","all","getImagesForSource","source","options","request","blob","overviews","url","assertEqual","expected","got","tolerance","message","rejector","isArray","length","Error","Math","abs","getMinForDataType","array","Int8Array","Int16Array","Int32Array","Float32Array","getMaxForDataType","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","GeoTIFFSource","constructor","state","tileGrid","opaque","transition","interpolate","wrapX","sourceInfo_","sources","numSources","sourceOptions_","sourceOptions","sourceImagery_","sourceMasks_","resolutionFactors_","samplesPerPixel_","nodataValues_","metadata_","normalize_","normalize","addAlpha_","error_","convertToRGB_","convertToRGB","setKey","map","join","self","configure_","catch","setState","getError","determineProjection","firstSource","extent","origin","commonRenderTileSizes","commonSourceTileSizes","resolutions","samplesPerPixel","nodataValues","metadata","minZoom","sourceCount","sourceIndex","images","masks","forEach","item","push","imageCount","sourceExtent","sourceOrigin","sourceTileSizes","renderTileSizes","sourceResolutions","imageIndex","nodataValue","getGDALNoData","getGDALMetadata","wantedSamples","bands","level","imageResolutions","sourceTileSize","getTileWidth","getTileHeight","aspectRatio","viewRejector","resolutionFactor","scaledSourceResolutions","resolution","reverse","ii","sourceImagery","unshift","undefined","outer","nodata","values","bandCount","tileSizes","setTileSizes","setLoader","loadTile_","bind","zoom","viewResolver","showFullExtent","center","z","x","y","getTileSize","sourceInfo","pool","pixelBounds","round","samples","bandNumber","fillValue","sampleIndex","readOptions","window","width","height","interleave","readRasters","maskIndex","mask","resolve","composeTile_","sourceSamples","addAlpha","pixelCount","dataLength","data","dataIndex","pixelIndex","transparent","min","max","gain","bias","stats","parseFloat","sourceValue","value","bandIndex","nodataIsNaN","isNaN","prototype","getView"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/source/GeoTIFF.js"],"sourcesContent":["/**\n * @module ol/source/GeoTIFF\n */\nimport DataTile from './DataTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport {\n  Pool,\n  globals as geotiffGlobals,\n  fromBlob as tiffFromBlob,\n  fromUrl as tiffFromUrl,\n  fromUrls as tiffFromUrls,\n} from 'geotiff';\nimport {\n  Projection,\n  get as getCachedProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {clamp} from '../math.js';\nimport {getCenter, getIntersection} from '../extent.js';\nimport {error as logError} from '../console.js';\nimport {fromCode as unitsFromCode} from '../proj/Units.js';\n\n/**\n * Determine if an image type is a mask.\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} The image is a mask.\n */\nfunction isMask(image) {\n  const fileDirectory = image.fileDirectory;\n  const type = fileDirectory.NewSubfileType || 0;\n  return (type & 4) === 4;\n}\n\n/**\n * @param {true|false|'auto'} preference The convertToRGB option.\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} Use the `image.readRGB()` method.\n */\nfunction readRGB(preference, image) {\n  if (!preference) {\n    return false;\n  }\n  if (preference === true) {\n    return true;\n  }\n  if (image.getSamplesPerPixel() !== 3) {\n    return false;\n  }\n  const interpretation = image.fileDirectory.PhotometricInterpretation;\n  const interpretations = geotiffGlobals.photometricInterpretations;\n  return (\n    interpretation === interpretations.CMYK ||\n    interpretation === interpretations.YCbCr ||\n    interpretation === interpretations.CIELab ||\n    interpretation === interpretations.ICCLab\n  );\n}\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\n\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n\nconst defaultTileSize = 256;\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\n\nlet workerPool;\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool();\n  }\n  return workerPool;\n}\n\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox();\n  } catch (_) {\n    return [0, 0, image.getWidth(), image.getHeight()];\n  }\n}\n\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch (_) {\n    return [0, image.getHeight()];\n  }\n}\n\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\nfunction getResolutions(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage);\n  } catch (_) {\n    return [\n      referenceImage.getWidth() / image.getWidth(),\n      referenceImage.getHeight() / image.getHeight(),\n    ];\n  }\n}\n\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\nfunction getProjection(image) {\n  const geoKeys = image.geoKeys;\n  if (!geoKeys) {\n    return null;\n  }\n\n  if (\n    geoKeys.ProjectedCSTypeGeoKey &&\n    geoKeys.ProjectedCSTypeGeoKey !== 32767\n  ) {\n    const code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  if (geoKeys.GeographicTypeGeoKey && geoKeys.GeographicTypeGeoKey !== 32767) {\n    const code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  return null;\n}\n\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    const requests = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n    return Promise.all(requests);\n  });\n}\n\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n  let request;\n  if (source.blob) {\n    request = tiffFromBlob(source.blob);\n  } else if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews, options);\n  } else {\n    request = tiffFromUrl(source.url, options);\n  }\n  return request.then(getImagesForTIFF);\n}\n\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    const length = expected.length;\n    if (!Array.isArray(got) || length != got.length) {\n      const error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n    for (let i = 0; i < length; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n    return;\n  }\n\n  got = /** @type {number} */ (got);\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n  return 0;\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n  return 255;\n}\n\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\n * CIELab, and ICCLab images will automatically be converted to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\n * will be read for projection information.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * **Note for users of the full build**: The `GeoTIFF` source requires the\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\n *\n * @api\n */\nclass GeoTIFFSource extends DataTile {\n  /**\n   * @param {Options} options Data tile options.\n   */\n  constructor(options) {\n    super({\n      state: 'loading',\n      tileGrid: null,\n      projection: options.projection || null,\n      opaque: options.opaque,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n    this.sourceInfo_ = options.sources;\n\n    const numSources = this.sourceInfo_.length;\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.sourceOptions_ = options.sourceOptions;\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceImagery_ = new Array(numSources);\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceMasks_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.resolutionFactors_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.samplesPerPixel_;\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.nodataValues_;\n\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n    this.metadata_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.normalize_ = options.normalize !== false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.addAlpha_ = false;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {true|false|'auto'}\n     */\n    this.convertToRGB_ = options.convertToRGB || false;\n\n    this.setKey(this.sourceInfo_.map((source) => source.url).join(','));\n\n    const self = this;\n    const requests = new Array(numSources);\n    for (let i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(\n        this.sourceInfo_[i],\n        this.sourceOptions_\n      );\n    }\n    Promise.all(requests)\n      .then(function (sources) {\n        self.configure_(sources);\n      })\n      .catch(function (error) {\n        logError(error);\n        self.error_ = error;\n        self.setState('error');\n      });\n  }\n\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Determine the projection of the images in this GeoTIFF.\n   * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey\n   * of each image in turn.\n   * You can override this method in a subclass to support more projections.\n   *\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   */\n  determineProjection(sources) {\n    const firstSource = sources[0];\n    for (let i = firstSource.length - 1; i >= 0; --i) {\n      const image = firstSource[i];\n      const projection = getProjection(image);\n      if (projection) {\n        this.projection = projection;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n   * must have the same internal tiled structure.\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   * @private\n   */\n  configure_(sources) {\n    let extent;\n    let origin;\n    let commonRenderTileSizes;\n    let commonSourceTileSizes;\n    let resolutions;\n    const samplesPerPixel = new Array(sources.length);\n    const nodataValues = new Array(sources.length);\n    const metadata = new Array(sources.length);\n    let minZoom = 0;\n\n    const sourceCount = sources.length;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const images = [];\n      const masks = [];\n      sources[sourceIndex].forEach((item) => {\n        if (isMask(item)) {\n          masks.push(item);\n        } else {\n          images.push(item);\n        }\n      });\n\n      const imageCount = images.length;\n      if (masks.length > 0 && masks.length !== imageCount) {\n        throw new Error(\n          `Expected one mask per image found ${masks.length} masks and ${imageCount} images`\n        );\n      }\n\n      let sourceExtent;\n      let sourceOrigin;\n      const sourceTileSizes = new Array(imageCount);\n      const renderTileSizes = new Array(imageCount);\n      const sourceResolutions = new Array(imageCount);\n\n      nodataValues[sourceIndex] = new Array(imageCount);\n      metadata[sourceIndex] = new Array(imageCount);\n\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n        const image = images[imageIndex];\n        const nodataValue = image.getGDALNoData();\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\n\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\n        samplesPerPixel[sourceIndex] = wantedSamples\n          ? wantedSamples.length\n          : image.getSamplesPerPixel();\n        const level = imageCount - (imageIndex + 1);\n\n        if (!sourceExtent) {\n          sourceExtent = getBoundingBox(image);\n        }\n\n        if (!sourceOrigin) {\n          sourceOrigin = getOrigin(image);\n        }\n\n        const imageResolutions = getResolutions(image, images[0]);\n        sourceResolutions[level] = imageResolutions[0];\n\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n\n        // request larger blocks for untiled layouts\n        if (\n          sourceTileSize[0] !== sourceTileSize[1] &&\n          sourceTileSize[1] < defaultTileSize\n        ) {\n          sourceTileSize[0] = defaultTileSize;\n          sourceTileSize[1] = defaultTileSize;\n        }\n\n        sourceTileSizes[level] = sourceTileSize;\n\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n        renderTileSizes[level] = [\n          sourceTileSize[0],\n          sourceTileSize[1] / aspectRatio,\n        ];\n      }\n\n      if (!extent) {\n        extent = sourceExtent;\n      } else {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      if (!origin) {\n        origin = sourceOrigin;\n      } else {\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\n      }\n\n      if (!resolutions) {\n        resolutions = sourceResolutions;\n        this.resolutionFactors_[sourceIndex] = 1;\n      } else {\n        if (resolutions.length - minZoom > sourceResolutions.length) {\n          minZoom = resolutions.length - sourceResolutions.length;\n        }\n        const resolutionFactor =\n          resolutions[resolutions.length - 1] /\n          sourceResolutions[sourceResolutions.length - 1];\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\n        const scaledSourceResolutions = sourceResolutions.map(\n          (resolution) => (resolution *= resolutionFactor)\n        );\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\n        assertEqual(\n          resolutions.slice(minZoom, resolutions.length),\n          scaledSourceResolutions,\n          0.02,\n          message,\n          this.viewRejector\n        );\n      }\n\n      if (!commonRenderTileSizes) {\n        commonRenderTileSizes = renderTileSizes;\n      } else {\n        assertEqual(\n          commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length),\n          renderTileSizes,\n          0.01,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector\n        );\n      }\n\n      if (!commonSourceTileSizes) {\n        commonSourceTileSizes = sourceTileSizes;\n      } else {\n        assertEqual(\n          commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length),\n          sourceTileSizes,\n          0,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector\n        );\n      }\n\n      this.sourceImagery_[sourceIndex] = images.reverse();\n      this.sourceMasks_[sourceIndex] = masks.reverse();\n    }\n\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n      const sourceImagery = this.sourceImagery_[i];\n      while (sourceImagery.length < resolutions.length) {\n        sourceImagery.unshift(undefined);\n      }\n    }\n\n    if (!this.getProjection()) {\n      this.determineProjection(sources);\n    }\n\n    this.samplesPerPixel_ = samplesPerPixel;\n    this.nodataValues_ = nodataValues;\n    this.metadata_ = metadata;\n\n    // decide if we need to add an alpha band to handle nodata\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      // option 1: source is configured with a nodata value\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n        this.addAlpha_ = true;\n        break;\n      }\n      if (this.sourceMasks_[sourceIndex].length) {\n        this.addAlpha_ = true;\n        break;\n      }\n\n      const values = nodataValues[sourceIndex];\n\n      // option 2: check image metadata for limited bands\n      const bands = this.sourceInfo_[sourceIndex].bands;\n      if (bands) {\n        for (let i = 0; i < bands.length; ++i) {\n          if (values[bands[i] - 1] !== null) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n        continue;\n      }\n\n      // option 3: check image metadata for all bands\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n        if (values[imageIndex] !== null) {\n          this.addAlpha_ = true;\n          break outer;\n        }\n      }\n    }\n\n    let bandCount = this.addAlpha_ ? 1 : 0;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      bandCount += samplesPerPixel[sourceIndex];\n    }\n    this.bandCount = bandCount;\n\n    const tileGrid = new TileGrid({\n      extent: extent,\n      minZoom: minZoom,\n      origin: origin,\n      resolutions: resolutions,\n      tileSizes: commonRenderTileSizes,\n    });\n\n    this.tileGrid = tileGrid;\n    this.setTileSizes(commonSourceTileSizes);\n\n    this.setLoader(this.loadTile_.bind(this));\n    this.setState('ready');\n\n    const zoom = 1;\n    if (resolutions.length === 2) {\n      resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\n    } else if (resolutions.length === 1) {\n      resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\n    }\n\n    this.viewResolver({\n      showFullExtent: true,\n      projection: this.projection,\n      resolutions: resolutions,\n      center: toUserCoordinate(getCenter(extent), this.projection),\n      extent: toUserExtent(extent, this.projection),\n      zoom: zoom,\n    });\n  }\n\n  /**\n   * @param {number} z The z tile index.\n   * @param {number} x The x tile index.\n   * @param {number} y The y tile index.\n   * @return {Promise} The composed tile data.\n   * @private\n   */\n  loadTile_(z, x, y) {\n    const sourceTileSize = this.getTileSize(z);\n    const sourceCount = this.sourceImagery_.length;\n    const requests = new Array(sourceCount * 2);\n    const nodataValues = this.nodataValues_;\n    const sourceInfo = this.sourceInfo_;\n    const pool = getWorkerPool();\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const source = sourceInfo[sourceIndex];\n      const resolutionFactor = this.resolutionFactors_[sourceIndex];\n      const pixelBounds = [\n        Math.round(x * (sourceTileSize[0] * resolutionFactor)),\n        Math.round(y * (sourceTileSize[1] * resolutionFactor)),\n        Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)),\n        Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor)),\n      ];\n      const image = this.sourceImagery_[sourceIndex][z];\n      let samples;\n      if (source.bands) {\n        samples = source.bands.map(function (bandNumber) {\n          return bandNumber - 1;\n        });\n      }\n\n      /** @type {number|Array<number>} */\n      let fillValue;\n      if ('nodata' in source && source.nodata !== null) {\n        fillValue = source.nodata;\n      } else {\n        if (!samples) {\n          fillValue = nodataValues[sourceIndex];\n        } else {\n          fillValue = samples.map(function (sampleIndex) {\n            return nodataValues[sourceIndex][sampleIndex];\n          });\n        }\n      }\n\n      const readOptions = {\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: samples,\n        fillValue: fillValue,\n        pool: pool,\n        interleave: false,\n      };\n      if (readRGB(this.convertToRGB_, image)) {\n        requests[sourceIndex] = image.readRGB(readOptions);\n      } else {\n        requests[sourceIndex] = image.readRasters(readOptions);\n      }\n\n      // requests after `sourceCount` are for mask data (if any)\n      const maskIndex = sourceCount + sourceIndex;\n      const mask = this.sourceMasks_[sourceIndex][z];\n      if (!mask) {\n        requests[maskIndex] = Promise.resolve(null);\n        continue;\n      }\n\n      requests[maskIndex] = mask.readRasters({\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: [0],\n        pool: pool,\n        interleave: false,\n      });\n    }\n\n    return Promise.all(requests)\n      .then(this.composeTile_.bind(this, sourceTileSize))\n      .catch(function (error) {\n        logError(error);\n        throw error;\n      });\n  }\n\n  /**\n   * @param {import(\"../size.js\").Size} sourceTileSize The source tile size.\n   * @param {Array} sourceSamples The source samples.\n   * @return {import(\"../DataTile.js\").Data} The composed tile data.\n   * @private\n   */\n  composeTile_(sourceTileSize, sourceSamples) {\n    const metadata = this.metadata_;\n    const sourceInfo = this.sourceInfo_;\n    const sourceCount = this.sourceImagery_.length;\n    const bandCount = this.bandCount;\n    const samplesPerPixel = this.samplesPerPixel_;\n    const nodataValues = this.nodataValues_;\n    const normalize = this.normalize_;\n    const addAlpha = this.addAlpha_;\n\n    const pixelCount = sourceTileSize[0] * sourceTileSize[1];\n    const dataLength = pixelCount * bandCount;\n\n    /** @type {Uint8Array|Float32Array} */\n    let data;\n    if (normalize) {\n      data = new Uint8Array(dataLength);\n    } else {\n      data = new Float32Array(dataLength);\n    }\n\n    let dataIndex = 0;\n    for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n      let transparent = addAlpha;\n      for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n        const source = sourceInfo[sourceIndex];\n\n        let min = source.min;\n        let max = source.max;\n        let gain, bias;\n        if (normalize) {\n          const stats = metadata[sourceIndex][0];\n          if (min === undefined) {\n            if (stats && STATISTICS_MINIMUM in stats) {\n              min = parseFloat(stats[STATISTICS_MINIMUM]);\n            } else {\n              min = getMinForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n          if (max === undefined) {\n            if (stats && STATISTICS_MAXIMUM in stats) {\n              max = parseFloat(stats[STATISTICS_MAXIMUM]);\n            } else {\n              max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n\n          gain = 255 / (max - min);\n          bias = -min * gain;\n        }\n\n        for (\n          let sampleIndex = 0;\n          sampleIndex < samplesPerPixel[sourceIndex];\n          ++sampleIndex\n        ) {\n          const sourceValue =\n            sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n\n          let value;\n          if (normalize) {\n            value = clamp(gain * sourceValue + bias, 0, 255);\n          } else {\n            value = sourceValue;\n          }\n\n          if (!addAlpha) {\n            data[dataIndex] = value;\n          } else {\n            let nodata = source.nodata;\n            if (nodata === undefined) {\n              let bandIndex;\n              if (source.bands) {\n                bandIndex = source.bands[sampleIndex] - 1;\n              } else {\n                bandIndex = sampleIndex;\n              }\n              nodata = nodataValues[sourceIndex][bandIndex];\n            }\n\n            const nodataIsNaN = isNaN(nodata);\n            if (\n              (!nodataIsNaN && sourceValue !== nodata) ||\n              (nodataIsNaN && !isNaN(sourceValue))\n            ) {\n              transparent = false;\n              data[dataIndex] = value;\n            }\n          }\n          dataIndex++;\n        }\n        if (!transparent) {\n          const maskIndex = sourceCount + sourceIndex;\n          const mask = sourceSamples[maskIndex];\n          if (mask && !mask[0][pixelIndex]) {\n            transparent = true;\n          }\n        }\n      }\n      if (addAlpha) {\n        if (!transparent) {\n          data[dataIndex] = 255;\n        }\n        dataIndex++;\n      }\n    }\n\n    return data;\n  }\n}\n\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\n\nexport default GeoTIFFSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}