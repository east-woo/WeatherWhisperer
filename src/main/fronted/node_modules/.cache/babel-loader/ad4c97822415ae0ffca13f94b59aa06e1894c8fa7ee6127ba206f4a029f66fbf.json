{"ast":null,"code":"/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1:\n      // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2:\n      // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3:\n      // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2 ? tileHeight * tileWidth : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2 ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n  if (format === 1) {\n    // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = bitsPerLine + 7 & ~7;\n    }\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + x * samplesToTransfer * bitsPerSample;\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + i * bitsPerSample;\n          const outIndex = (y * tileWidth + x) * samplesToTransfer + i;\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = view.getUint8(byteOffset) >> 8 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = view.getUint16(byteOffset) >> 16 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = view.getUint16(byteOffset) << 8 | view.getUint8(byteOffset + 2);\n            outArray[outIndex] = raw >> 24 - bitsPerSample - innerBitOffset & bitMask;\n          } else {\n            outArray[outIndex] = view.getUint32(byteOffset) >> 32 - bitsPerSample - innerBitOffset & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) {// floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = typeof planarConfiguration === 'undefined' ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined' ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - y * this.getTileHeight();\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1:\n        // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2:\n        // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const {\n      tiles\n    } = this;\n    if (this.planarConfiguration === 1) {\n      index = y * numTilesPerRow + x;\n    } else if (this.planarConfiguration === 2) {\n      index = sample * numTilesPerRow * numTilesPerCol + y * numTilesPerRow + x;\n    }\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{\n      offset,\n      length: byteCount\n    }], signal))[0];\n    let request;\n    if (tiles === null || !tiles[index]) {\n      // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(data, sampleFormat, this.planarConfiguration, this.getSamplesPerPixel(), bitsPerSample, this.getTileWidth(), this.getBlockHeight(y));\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return {\n      x,\n      y,\n      sample,\n      data: await request\n    };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(Math.ceil(imageWindow[2] / tileWidth), Math.ceil(imageWidth / tileWidth));\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(Math.ceil(imageWindow[3] / tileHeight), Math.ceil(imageHeight / tileHeight));\n    const windowWidth = imageWindow[2] - imageWindow[0];\n    let bytesPerPixel = this.getBytesPerPixel();\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n    const promises = [];\n    const {\n      littleEndian\n    } = this;\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then(tile => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = (y * tileWidth + x) * bytesPerPixel;\n                const value = reader.call(dataView, pixelOffset + srcSampleOffsets[si], littleEndian);\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth * samples.length + (x + firstCol - imageWindow[0]) * samples.length + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n    if (width && imageWindow[2] - imageWindow[0] !== width || height && imageWindow[3] - imageWindow[1] !== height) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, samples.length, resampleMethod);\n      } else {\n        resampled = resample(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, resampleMethod);\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd,\n    samples = [],\n    interleave,\n    pool = null,\n    width,\n    height,\n    resampleMethod,\n    fillValue,\n    signal\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n    const poolOrDecoder = pool || (await getDecoder(this.fileDirectory));\n    const result = await this._readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal);\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({\n    window,\n    interleave = true,\n    pool = null,\n    width,\n    height,\n    resampleMethod,\n    enableAlpha = false,\n    signal\n  } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n    const pi = this.fileDirectory.PhotometricInterpretation;\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if (!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal\n      });\n    }\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal\n    };\n    const {\n      fileDirectory\n    } = this;\n    const raster = await this.readRasters(subOptions);\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5]\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n    let items = findTagsByName(string, 'Item');\n    if (sample === null) {\n      items = items.filter(item => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter(item => Number(getAttribute(item, 'sample')) === sample);\n    }\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [tiePoints[3], tiePoints[4], tiePoints[5]];\n    }\n    if (modelTransformation) {\n      return [modelTransformation[3], modelTransformation[7], modelTransformation[11]];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (modelPixelScale) {\n      return [modelPixelScale[0], -modelPixelScale[1], modelPixelScale[2]];\n    }\n    if (modelTransformation) {\n      return [modelTransformation[0], -modelTransformation[5], modelTransformation[10]];\n    }\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [refResX * referenceImage.getWidth() / this.getWidth(), refResY * referenceImage.getHeight() / this.getHeight(), refResZ * referenceImage.getWidth() / this.getWidth()];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid \n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n      const corners = [[0, 0], [0, height], [width, 0], [width, height]];\n      const projected = corners.map(([I, J]) => [d + a * I + b * J, h + e * I + f * J]);\n      const xs = projected.map(pt => pt[0]);\n      const ys = projected.map(pt => pt[1]);\n      return [Math.min(...xs), Math.min(...ys), Math.max(...xs), Math.max(...ys)];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n      const x1 = origin[0];\n      const y1 = origin[1];\n      const x2 = x1 + resolution[0] * width;\n      const y2 = y1 + resolution[1] * height;\n      return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n    }\n  }\n}\nexport default GeoTIFFImage;","map":{"version":3,"names":["getFloat16","getAttribute","findTagsByName","photometricInterpretations","ExtraSamplesValues","fromWhiteIsZero","fromBlackIsZero","fromPalette","fromCMYK","fromYCbCr","fromCIELab","getDecoder","resample","resampleInterleaved","sum","array","start","end","s","i","arrayForType","format","bitsPerSample","size","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","Error","needsNormalization","normalizeArray","inBuffer","planarConfiguration","samplesPerPixel","tileWidth","tileHeight","view","DataView","outSize","samplesToTransfer","outArray","bitMask","parseInt","repeat","pixelBitSkip","bitsPerLine","y","lineBitOffset","x","pixelBitOffset","bitOffset","outIndex","byteOffset","Math","floor","innerBitOffset","getUint8","getUint16","raw","getUint32","buffer","GeoTIFFImage","constructor","fileDirectory","geoKeys","dataView","littleEndian","cache","source","tiles","isTiled","StripOffsets","PlanarConfiguration","getFileDirectory","getGeoKeys","getWidth","ImageWidth","getHeight","ImageLength","getSamplesPerPixel","SamplesPerPixel","getTileWidth","TileWidth","getTileHeight","TileLength","RowsPerStrip","min","getBlockWidth","getBlockHeight","getBytesPerPixel","bytes","BitsPerSample","length","getSampleByteSize","RangeError","ceil","getReaderForSample","sampleIndex","SampleFormat","prototype","getInt8","getInt16","getInt32","offset","getFloat32","getFloat64","getSampleFormat","getBitsPerSample","getArrayForSample","getTileOrStrip","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","index","byteCount","TileOffsets","TileByteCounts","StripByteCounts","slice","fetch","request","data","decode","sampleFormat","_readRaster","imageWindow","samples","valueArrays","interleave","width","height","resampleMethod","imageWidth","imageHeight","minXTile","max","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","push","promises","yTile","xTile","getPromise","si","promise","then","tile","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","value","call","windowCoordinate","Promise","all","resampled","readRasters","window","wnd","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","reject","apply","fill","valueArray","Array","isArray","result","readRGB","enableAlpha","pi","PhotometricInterpretation","RGB","ExtraSamples","Unspecified","WhiteIsZero","BlackIsZero","Palette","CMYK","YCbCr","CIELab","subOptions","raster","ColorMap","red","green","blue","j","getTiePoints","ModelTiepoint","tiePoints","k","z","getGDALMetadata","metadata","GDAL_METADATA","string","items","filter","item","undefined","Number","inner","getGDALNoData","GDAL_NODATA","substring","getOrigin","modelTransformation","ModelTransformation","getResolution","referenceImage","modelPixelScale","ModelPixelScale","refResX","refResY","refResZ","pixelIsArea","GTRasterTypeGeoKey","getBoundingBox","tilegrid","a","b","c","d","e","f","g","h","corners","projected","map","I","J","xs","pt","ys","origin","resolution","x1","y1","x2","y2"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/geotiff/dist-module/geotiffimage.js"],"sourcesContent":["/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        -modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid \n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\nexport default GeoTIFFImage;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}