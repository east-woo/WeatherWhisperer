{"ast":null,"code":"function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n    length -= stride;\n  } while (length > 0);\n}\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[bytesPerSample * i + b] = copy[(bytesPerSample - b - 1) * wc + i];\n    }\n  }\n}\nexport function applyPredictor(block, predictor, width, height, bitsPerSample, planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) {\n      // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample);\n          break;\n        case 16:\n          row = new Uint16Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2);\n          break;\n        case 32:\n          row = new Uint32Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4);\n          break;\n        default:\n          throw new Error(\"Predictor 2 not allowed with \".concat(bitsPerSample[0], \" bits per sample.\"));\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) {\n      // horizontal floating point\n      row = new Uint8Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample);\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}","map":{"version":3,"names":["decodeRowAcc","row","stride","length","offset","i","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","slice","b","applyPredictor","block","predictor","width","height","bitsPerSample","planarConfiguration","Error","byteLength","Uint8Array","Uint16Array","Uint32Array","concat"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/geotiff/dist-module/predictor.js"],"sourcesContent":["function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}