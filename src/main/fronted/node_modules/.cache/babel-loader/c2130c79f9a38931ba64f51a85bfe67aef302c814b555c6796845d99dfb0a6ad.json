{"ast":null,"code":"import { getDecoder } from './compression/index.js';\nconst defaultPoolSize = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency || 2 : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise(resolve => {\n        import('./worker/decoder.js').then(module => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then(create => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({\n            worker: create(),\n            idle: true\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0 ? getDecoder(fileDirectory).then(decoder => decoder.decode(fileDirectory, buffer)) : new Promise(resolve => {\n      const worker = this.workers.find(candidate => candidate.idle) || this.workers[Math.floor(Math.random() * this.size)];\n      worker.idle = false;\n      const id = this.messageId++;\n      const onMessage = e => {\n        if (e.data.id === id) {\n          worker.idle = true;\n          resolve(e.data.decoded);\n          worker.worker.removeEventListener('message', onMessage);\n        }\n      };\n      worker.worker.addEventListener('message', onMessage);\n      worker.worker.postMessage({\n        fileDirectory,\n        buffer,\n        id\n      }, [buffer]);\n    });\n  }\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach(worker => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\nexport default Pool;","map":{"version":3,"names":["getDecoder","defaultPoolSize","navigator","hardwareConcurrency","Pool","constructor","size","createWorker","workers","_awaitingDecoder","messageId","Promise","resolve","then","module","create","i","push","worker","idle","decode","fileDirectory","buffer","decoder","find","candidate","Math","floor","random","id","onMessage","e","data","decoded","removeEventListener","addEventListener","postMessage","destroy","forEach","terminate"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/geotiff/dist-module/pool.js"],"sourcesContent":["import { getDecoder } from './compression/index.js';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        import('./worker/decoder.js').then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? getDecoder(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\nexport default Pool;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}