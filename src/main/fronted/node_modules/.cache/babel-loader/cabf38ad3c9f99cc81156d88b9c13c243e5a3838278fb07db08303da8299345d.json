{"ast":null,"code":"/**\n * @module ol/color\n */\nimport lchuv from 'color-space/lchuv.js';\nimport parseRgba from 'color-rgba';\nimport rgb from 'color-space/rgb.js';\nimport xyz from 'color-space/xyz.js';\nimport { clamp } from './math.js';\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  }\n  return toString(color);\n}\n\n/**\n * @type {number}\n */\nconst MAX_CACHE_SIZE = 1024;\n\n/**\n * We maintain a small cache of parsed strings.  Whenever the cache grows too large,\n * we delete an arbitrary set of the entries.\n *\n * @type {Object<string, Color>}\n */\nconst cache = {};\n\n/**\n * @type {number}\n */\nlet cacheSize = 0;\n\n/**\n * @param {Color} color A color that may or may not have an alpha channel.\n * @return {Color} The input color with an alpha channel.  If the input color has\n * an alpha channel, the input color will be returned unchanged.  Otherwise, a new\n * array will be returned with the input color and an alpha channel of 1.\n */\nexport function withAlpha(color) {\n  if (color.length === 4) {\n    return color;\n  }\n  const output = color.slice();\n  output[3] = 1;\n  return output;\n}\n\n/**\n * @param {Color} color RGBA color.\n * @return {Color} LCHuv color with alpha.\n */\nexport function rgbaToLcha(color) {\n  const output = xyz.lchuv(rgb.xyz(color));\n  output[3] = color[3];\n  return output;\n}\n\n/**\n * @param {Color} color LCHuv color with alpha.\n * @return {Color} RGBA color.\n */\nexport function lchaToRgba(color) {\n  const output = xyz.rgb(lchuv.xyz(color));\n  output[3] = color[3];\n  return output;\n}\n\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport function fromString(s) {\n  if (cache.hasOwnProperty(s)) {\n    return cache[s];\n  }\n  if (cacheSize >= MAX_CACHE_SIZE) {\n    let i = 0;\n    for (const key in cache) {\n      if ((i++ & 3) === 0) {\n        delete cache[key];\n        --cacheSize;\n      }\n    }\n  }\n  const color = parseRgba(s);\n  if (color.length !== 4) {\n    throw new Error('Failed to parse \"' + s + '\" as color');\n  }\n  for (const c of color) {\n    if (isNaN(c)) {\n      throw new Error('Failed to parse \"' + s + '\" as color');\n    }\n  }\n  normalize(color);\n  cache[s] = color;\n  ++cacheSize;\n  return color;\n}\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  }\n  return fromString(color);\n}\n\n/**\n * Exported for the tests.\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\nexport function normalize(color) {\n  color[0] = clamp(color[0] + 0.5 | 0, 0, 255);\n  color[1] = clamp(color[1] + 0.5 | 0, 0, 255);\n  color[2] = clamp(color[2] + 0.5 | 0, 0, 255);\n  color[3] = clamp(color[3], 0, 1);\n  return color;\n}\n\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n  let r = color[0];\n  if (r != (r | 0)) {\n    r = r + 0.5 | 0;\n  }\n  let g = color[1];\n  if (g != (g | 0)) {\n    g = g + 0.5 | 0;\n  }\n  let b = color[2];\n  if (b != (b | 0)) {\n    b = b + 0.5 | 0;\n  }\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\nexport function isStringColor(s) {\n  try {\n    fromString(s);\n    return true;\n  } catch (_) {\n    return false;\n  }\n}","map":{"version":3,"names":["lchuv","parseRgba","rgb","xyz","clamp","asString","color","toString","MAX_CACHE_SIZE","cache","cacheSize","withAlpha","length","output","slice","rgbaToLcha","lchaToRgba","fromString","s","hasOwnProperty","i","key","Error","c","isNaN","normalize","asArray","Array","isArray","r","g","b","a","undefined","Math","round","isStringColor","_"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/color.js"],"sourcesContent":["/**\n * @module ol/color\n */\nimport lchuv from 'color-space/lchuv.js';\nimport parseRgba from 'color-rgba';\nimport rgb from 'color-space/rgb.js';\nimport xyz from 'color-space/xyz.js';\nimport {clamp} from './math.js';\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  }\n  return toString(color);\n}\n\n/**\n * @type {number}\n */\nconst MAX_CACHE_SIZE = 1024;\n\n/**\n * We maintain a small cache of parsed strings.  Whenever the cache grows too large,\n * we delete an arbitrary set of the entries.\n *\n * @type {Object<string, Color>}\n */\nconst cache = {};\n\n/**\n * @type {number}\n */\nlet cacheSize = 0;\n\n/**\n * @param {Color} color A color that may or may not have an alpha channel.\n * @return {Color} The input color with an alpha channel.  If the input color has\n * an alpha channel, the input color will be returned unchanged.  Otherwise, a new\n * array will be returned with the input color and an alpha channel of 1.\n */\nexport function withAlpha(color) {\n  if (color.length === 4) {\n    return color;\n  }\n  const output = color.slice();\n  output[3] = 1;\n  return output;\n}\n\n/**\n * @param {Color} color RGBA color.\n * @return {Color} LCHuv color with alpha.\n */\nexport function rgbaToLcha(color) {\n  const output = xyz.lchuv(rgb.xyz(color));\n  output[3] = color[3];\n  return output;\n}\n\n/**\n * @param {Color} color LCHuv color with alpha.\n * @return {Color} RGBA color.\n */\nexport function lchaToRgba(color) {\n  const output = xyz.rgb(lchuv.xyz(color));\n  output[3] = color[3];\n  return output;\n}\n\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport function fromString(s) {\n  if (cache.hasOwnProperty(s)) {\n    return cache[s];\n  }\n  if (cacheSize >= MAX_CACHE_SIZE) {\n    let i = 0;\n    for (const key in cache) {\n      if ((i++ & 3) === 0) {\n        delete cache[key];\n        --cacheSize;\n      }\n    }\n  }\n\n  const color = parseRgba(s);\n  if (color.length !== 4) {\n    throw new Error('Failed to parse \"' + s + '\" as color');\n  }\n  for (const c of color) {\n    if (isNaN(c)) {\n      throw new Error('Failed to parse \"' + s + '\" as color');\n    }\n  }\n  normalize(color);\n  cache[s] = color;\n  ++cacheSize;\n  return color;\n}\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  }\n  return fromString(color);\n}\n\n/**\n * Exported for the tests.\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\nexport function normalize(color) {\n  color[0] = clamp((color[0] + 0.5) | 0, 0, 255);\n  color[1] = clamp((color[1] + 0.5) | 0, 0, 255);\n  color[2] = clamp((color[2] + 0.5) | 0, 0, 255);\n  color[3] = clamp(color[3], 0, 1);\n  return color;\n}\n\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n  let r = color[0];\n  if (r != (r | 0)) {\n    r = (r + 0.5) | 0;\n  }\n  let g = color[1];\n  if (g != (g | 0)) {\n    g = (g + 0.5) | 0;\n  }\n  let b = color[2];\n  if (b != (b | 0)) {\n    b = (b + 0.5) | 0;\n  }\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\nexport function isStringColor(s) {\n  try {\n    fromString(s);\n    return true;\n  } catch (_) {\n    return false;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}