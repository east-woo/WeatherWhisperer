{"ast":null,"code":"const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text.split('\\r\\n').map(line => {\n    const kv = line.split(':').map(str => str.trim());\n    kv[0] = kv[0].toLowerCase();\n    return kv;\n  });\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map(s => s.trim());\n  const paramsItems = rawParams.map(param => param.split('='));\n  return {\n    type,\n    params: itemsToObject(paramsItems)\n  };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n  return {\n    start,\n    end,\n    total\n  };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n  const startBoundary = \"--\".concat(boundary);\n  const endBoundary = \"\".concat(startBoundary, \"--\");\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(new Uint8Array(responseArrayBuffer, i, startBoundary.length));\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(new Uint8Array(responseArrayBuffer, offset, Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset)));\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const {\n      start,\n      end,\n      total\n    } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total\n    });\n    offset = startOfData + length + 4;\n  }\n  return out;\n}","map":{"version":3,"names":["CRLFCRLF","itemsToObject","items","Object","fromEntries","obj","key","value","toLowerCase","parseHeaders","text","split","map","line","kv","str","trim","parseContentType","rawContentType","type","rawParams","s","paramsItems","param","params","parseContentRange","rawContentRange","start","end","total","match","parseInt","parseByteRanges","responseArrayBuffer","boundary","offset","decoder","TextDecoder","out","startBoundary","concat","endBoundary","i","decode","Uint8Array","length","Error","byteLength","Math","min","startsWith","innerText","substr","endOfHeaders","indexOf","headers","startOfData","push","data","slice","fileSize"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/geotiff/dist-module/source/httputils.js"],"sourcesContent":["const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}