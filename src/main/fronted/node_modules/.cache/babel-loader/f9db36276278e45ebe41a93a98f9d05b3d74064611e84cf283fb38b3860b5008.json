{"ast":null,"code":"import { lerp } from '../../math.js';\n\n/**\n * Creates chunks of equal length from a linestring\n * @param {number} chunkLength Length of each chunk.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @return {Array<Array<number>>} Chunks of linestrings with stride 2.\n */\nexport function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {\n  const chunks = [];\n  let cursor = offset;\n  let chunkM = 0;\n  let currentChunk = flatCoordinates.slice(offset, 2);\n  while (chunkM < chunkLength && cursor + stride < end) {\n    const [x1, y1] = currentChunk.slice(-2);\n    const x2 = flatCoordinates[cursor + stride];\n    const y2 = flatCoordinates[cursor + stride + 1];\n    const segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    chunkM += segmentLength;\n    if (chunkM >= chunkLength) {\n      const m = (chunkLength - chunkM + segmentLength) / segmentLength;\n      const x = lerp(x1, x2, m);\n      const y = lerp(y1, y2, m);\n      currentChunk.push(x, y);\n      chunks.push(currentChunk);\n      currentChunk = [x, y];\n      if (chunkM == chunkLength) {\n        cursor += stride;\n      }\n      chunkM = 0;\n    } else if (chunkM < chunkLength) {\n      currentChunk.push(flatCoordinates[cursor + stride], flatCoordinates[cursor + stride + 1]);\n      cursor += stride;\n    } else {\n      const missing = segmentLength - chunkM;\n      const x = lerp(x1, x2, missing / segmentLength);\n      const y = lerp(y1, y2, missing / segmentLength);\n      currentChunk.push(x, y);\n      chunks.push(currentChunk);\n      currentChunk = [x, y];\n      chunkM = 0;\n      cursor += stride;\n    }\n  }\n  if (chunkM > 0) {\n    chunks.push(currentChunk);\n  }\n  return chunks;\n}","map":{"version":3,"names":["lerp","lineChunk","chunkLength","flatCoordinates","offset","end","stride","chunks","cursor","chunkM","currentChunk","slice","x1","y1","x2","y2","segmentLength","Math","sqrt","m","x","y","push","missing"],"sources":["C:/Users/dongwoo/Desktop/WeatherWhisperer/src/main/fronted/node_modules/ol/geom/flat/linechunk.js"],"sourcesContent":["import {lerp} from '../../math.js';\n\n/**\n * Creates chunks of equal length from a linestring\n * @param {number} chunkLength Length of each chunk.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @return {Array<Array<number>>} Chunks of linestrings with stride 2.\n */\nexport function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {\n  const chunks = [];\n  let cursor = offset;\n  let chunkM = 0;\n  let currentChunk = flatCoordinates.slice(offset, 2);\n  while (chunkM < chunkLength && cursor + stride < end) {\n    const [x1, y1] = currentChunk.slice(-2);\n    const x2 = flatCoordinates[cursor + stride];\n    const y2 = flatCoordinates[cursor + stride + 1];\n    const segmentLength = Math.sqrt(\n      (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)\n    );\n    chunkM += segmentLength;\n    if (chunkM >= chunkLength) {\n      const m = (chunkLength - chunkM + segmentLength) / segmentLength;\n      const x = lerp(x1, x2, m);\n      const y = lerp(y1, y2, m);\n      currentChunk.push(x, y);\n      chunks.push(currentChunk);\n      currentChunk = [x, y];\n      if (chunkM == chunkLength) {\n        cursor += stride;\n      }\n      chunkM = 0;\n    } else if (chunkM < chunkLength) {\n      currentChunk.push(\n        flatCoordinates[cursor + stride],\n        flatCoordinates[cursor + stride + 1]\n      );\n      cursor += stride;\n    } else {\n      const missing = segmentLength - chunkM;\n      const x = lerp(x1, x2, missing / segmentLength);\n      const y = lerp(y1, y2, missing / segmentLength);\n      currentChunk.push(x, y);\n      chunks.push(currentChunk);\n      currentChunk = [x, y];\n      chunkM = 0;\n      cursor += stride;\n    }\n  }\n  if (chunkM > 0) {\n    chunks.push(currentChunk);\n  }\n  return chunks;\n}\n"],"mappings":"AAAA,SAAQA,IAAI,QAAO,eAAe;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,SAASA,CAACC,WAAW,EAAEC,eAAe,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAE;EAC3E,MAAMC,MAAM,GAAG,EAAE;EACjB,IAAIC,MAAM,GAAGJ,MAAM;EACnB,IAAIK,MAAM,GAAG,CAAC;EACd,IAAIC,YAAY,GAAGP,eAAe,CAACQ,KAAK,CAACP,MAAM,EAAE,CAAC,CAAC;EACnD,OAAOK,MAAM,GAAGP,WAAW,IAAIM,MAAM,GAAGF,MAAM,GAAGD,GAAG,EAAE;IACpD,MAAM,CAACO,EAAE,EAAEC,EAAE,CAAC,GAAGH,YAAY,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC;IACvC,MAAMG,EAAE,GAAGX,eAAe,CAACK,MAAM,GAAGF,MAAM,CAAC;IAC3C,MAAMS,EAAE,GAAGZ,eAAe,CAACK,MAAM,GAAGF,MAAM,GAAG,CAAC,CAAC;IAC/C,MAAMU,aAAa,GAAGC,IAAI,CAACC,IAAI,CAC7B,CAACJ,EAAE,GAAGF,EAAE,KAAKE,EAAE,GAAGF,EAAE,CAAC,GAAG,CAACG,EAAE,GAAGF,EAAE,KAAKE,EAAE,GAAGF,EAAE,CAC9C,CAAC;IACDJ,MAAM,IAAIO,aAAa;IACvB,IAAIP,MAAM,IAAIP,WAAW,EAAE;MACzB,MAAMiB,CAAC,GAAG,CAACjB,WAAW,GAAGO,MAAM,GAAGO,aAAa,IAAIA,aAAa;MAChE,MAAMI,CAAC,GAAGpB,IAAI,CAACY,EAAE,EAAEE,EAAE,EAAEK,CAAC,CAAC;MACzB,MAAME,CAAC,GAAGrB,IAAI,CAACa,EAAE,EAAEE,EAAE,EAAEI,CAAC,CAAC;MACzBT,YAAY,CAACY,IAAI,CAACF,CAAC,EAAEC,CAAC,CAAC;MACvBd,MAAM,CAACe,IAAI,CAACZ,YAAY,CAAC;MACzBA,YAAY,GAAG,CAACU,CAAC,EAAEC,CAAC,CAAC;MACrB,IAAIZ,MAAM,IAAIP,WAAW,EAAE;QACzBM,MAAM,IAAIF,MAAM;MAClB;MACAG,MAAM,GAAG,CAAC;IACZ,CAAC,MAAM,IAAIA,MAAM,GAAGP,WAAW,EAAE;MAC/BQ,YAAY,CAACY,IAAI,CACfnB,eAAe,CAACK,MAAM,GAAGF,MAAM,CAAC,EAChCH,eAAe,CAACK,MAAM,GAAGF,MAAM,GAAG,CAAC,CACrC,CAAC;MACDE,MAAM,IAAIF,MAAM;IAClB,CAAC,MAAM;MACL,MAAMiB,OAAO,GAAGP,aAAa,GAAGP,MAAM;MACtC,MAAMW,CAAC,GAAGpB,IAAI,CAACY,EAAE,EAAEE,EAAE,EAAES,OAAO,GAAGP,aAAa,CAAC;MAC/C,MAAMK,CAAC,GAAGrB,IAAI,CAACa,EAAE,EAAEE,EAAE,EAAEQ,OAAO,GAAGP,aAAa,CAAC;MAC/CN,YAAY,CAACY,IAAI,CAACF,CAAC,EAAEC,CAAC,CAAC;MACvBd,MAAM,CAACe,IAAI,CAACZ,YAAY,CAAC;MACzBA,YAAY,GAAG,CAACU,CAAC,EAAEC,CAAC,CAAC;MACrBZ,MAAM,GAAG,CAAC;MACVD,MAAM,IAAIF,MAAM;IAClB;EACF;EACA,IAAIG,MAAM,GAAG,CAAC,EAAE;IACdF,MAAM,CAACe,IAAI,CAACZ,YAAY,CAAC;EAC3B;EACA,OAAOH,MAAM;AACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}